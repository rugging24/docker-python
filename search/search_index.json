{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Testcompose Testcompose provides an easy way of using docker containers for functional and integration testing. It allows for combination of more than one containers and allows for interactions with these containers from your test code without having to write extra scripts for such interactions. I.e providing a docker compose kind of functionality with the extra benefit of being able to fully control the containers from test codes. This is inspired by the testcontainers-python project and goes further to add a few additional functionality to imporve software integration testing while allowing the engineer control every aspect of the test. Install testcompose using pip: $ pip install testcompose testcompose requires Python 3.7+. You can either use a config file of the format: network : name : some_network_name # this must already exists !!! Default is bridge auto_create : False use_random_network : True services : - name : db1 image : \"postgres:13\" auto_remove : True command : \"\" environment : POSTGRES_USER : postgres POSTGRES_DB : postgres POSTGRES_PASSWORD : a exposed_ports : - 5432 volumes : - host : \"data_volume\" container : \"/data\" mode : \"rw\" log_wait_parameters : log_line_regex : \"database system is ready to accept connections\" wait_timeout : 30 poll_interval : 2 Verify it as follows: from testcompose.parse_config import TestConfigParser from testcompose.configs.service_config import Config from testcompose.run_containers import RunContainers my_test_service = TestConfigParser.parse_config( file_name='some-file-name' ) my_config = Config(test_services=my_test_service) print(my_config.ranked_itest_config_services) with RunContainers( services=running_config.ranked_itest_config_services ) as runner: # Do some work and/or interract with the running containers assert runner.containers # Or get some parameters about the running containers app_container = runner.extra_envs[\"app_container_config_name\"] mapped_port = app_container.get(\"DOCKER_PYTHON_MAPPED_PORTS\", {}).get(\"port\") Documentation For a run-through of all the basics, head over to the QuickStart . The Developer Interface provides a comprehensive API reference.","title":"Introduction"},{"location":"#documentation","text":"For a run-through of all the basics, head over to the QuickStart . The Developer Interface provides a comprehensive API reference.","title":"Documentation"},{"location":"api/","text":"Developer Reference testcompose.client.base_client.BaseClient ( ABC ) docker_client : DockerClient property writable Docker Client Returns: Type Description DockerClient docker client object max_pool_size max_timeout initialise_client ( self ) -> None This is the method that initializes the docker client and needs be implemented. Source code in testcompose/client/base_client.py @abstractmethod def initialise_client ( self ) -> None : \"\"\"This is the method that initializes the docker client and needs be implemented. \"\"\" ... testcompose.client.client_from_env.EnvClient ( BaseClient ) initialise_client ( self ) -> None Init docker client Returns: Type Description DockerClient docker client Source code in testcompose/client/client_from_env.py def initialise_client ( self ) -> None : \"\"\"Init docker client Returns: DockerClient: docker client \"\"\" self . docker_client = docker . from_env ( version = self . _version , timeout = self . _timeout , max_pool_size = self . _max_pool_size , use_ssh_client = self . _use_ssh_client , ssl_version = self . _ssl_version , assert_hostname = self . _assert_hostname , environment = self . _environment , ) testcompose.client.client_from_url.UrlClient ( BaseClient ) initialise_client ( self ) -> None Init docker client Returns: Type Description DockerClient docker client Source code in testcompose/client/client_from_url.py def initialise_client ( self ) -> None : \"\"\"Init docker client Returns: DockerClient: docker client \"\"\" self . docker_client = DockerClient ( base_url = self . _docker_host , version = self . _version , timeout = self . _timeout , tls = self . _tls , user_agent = self . _user_agent , credstor_env = self . _credstor_env , use_ssh_client = self . _use_ssh_client , max_pool_size = self . _max_pool_size , ) testcompose.configs.parse_config.TestConfigParser parse_config ( file_name : str ) -> ITestConfig classmethod parses and verifies test yaml config file Parameters: Name Type Description Default file_name str absolutel path of the config file required Exceptions: Type Description FileNotFoundError when config file not present AttributeError when config file is empty Returns: Type Description ITestConfig A ITestConfig object with all named services in the config Source code in testcompose/configs/parse_config.py @classmethod def parse_config ( cls , file_name : str ) -> ITestConfig : \"\"\"parses and verifies test yaml config file Args: file_name (str): absolutel path of the config file Raises: FileNotFoundError: when config file not present AttributeError: when config file is empty Returns: ITestConfig: A ITestConfig object with all named services in the config \"\"\" if not os . path . exists ( file_name ): raise FileNotFoundError ( f \"Config file { file_name } does not exist!!\" ) content : Dict [ str , Any ] = dict () with open ( file_name , 'r' ) as fh : content = yaml . safe_load ( fh ) if not content : raise AttributeError ( f \"Config content can not be empty\" ) test_services : ITestConfig = ITestConfig ( ** content ) return test_services testcompose.configs.service_config.Config This class consumes the model created from a config file. This is an important class that sets the precedence of how the different containers are to be started and stopped. Usually, the precedence are set correctly if the depends_on parameter of the config is set. Cyclic dependency will fail the test before it starts. Parameters: Name Type Description Default test_services ITestConfig model resulting from a parsed configuration file. required ranked_itest_config_services : RankedServices property writable Object containing the ordered services from the config Returns: Type Description RankedServices ranked container services testcompose.containers.container_builder.ContainerBuilder ( ABC ) Container Builder Parameters: Name Type Description Default ABC [type] required docker_client : DockerClient property writable Docker Client Returns: Type Description DockerClient client object generic_container_param : ContainerParam property writable Container parameter Returns: Type Description ContainerParam parameter model build ( self , docker_client : DockerClient ) -> None Build container parameters Parameters: Name Type Description Default docker_client DockerClient [description] required Source code in testcompose/containers/container_builder.py def build ( self , docker_client : DockerClient ) -> None : \"\"\"Build container parameters Args: docker_client (DockerClient): [description] \"\"\" self . docker_client = docker_client self . with_environment ( self . _container_param . environment_variables ) self . with_volumes ( self . _container_param . volumes ) self . with_exposed_ports ( self . _container_param . exposed_ports ) if self . generic_container_param . registry_login_param . username : login = self . docker_client . login ( ** self . generic_container_param . registry_login_param . dict ()) print ( login ) print ( f \"Pulling image { self . generic_container_param . image } \" ) self . pull_image () pull_image ( self , image_pull_policy = 'Always_Pull' ) Pull image of registry Pull polic can be one of the following: !!! image_pull_policy - Always_Pull [ default ] - Never Parameters: Name Type Description Default image_pull_policy str Image pull policy for the test. 'Always_Pull' Source code in testcompose/containers/container_builder.py def pull_image ( self , image_pull_policy = \"Always_Pull\" ): \"\"\"Pull image of registry Pull polic can be one of the following: image_pull_policy: - Always_Pull [default] - Never Args: image_pull_policy (str, optional): Image pull policy for the test. \"\"\" # TODO: Allow pull toggle try : self . docker_client . images . get ( name = self . generic_container_param . image ) except ImageNotFound : self . docker_client . images . pull ( repository = self . generic_container_param . image ) start ( self ) Source code in testcompose/containers/container_builder.py @abstractmethod def start ( self ): ... stop ( self ) Source code in testcompose/containers/container_builder.py @abstractmethod def stop ( self ): ... with_environment ( self , env : Optional [ Dict [ str , Any ]]) Environment variables for running containers Parameters: Name Type Description Default env Optional[Dict[str, Any]] [description] required Source code in testcompose/containers/container_builder.py def with_environment ( self , env : Optional [ Dict [ str , Any ]]): \"\"\"Environment variables for running containers Args: env (Optional[Dict[str, Any]]): [description] \"\"\" if env : for k , v in env . items (): self . _environments [ k ] = v with_exposed_ports ( self , ports : Optional [ List [ str ]]) List of exposed port to be assigned random port numbers on the host. Random ports are exposed to the host. A fixed port can be assigned on the host by providing the port in the format [host_port:container_port] Parameters: Name Type Description Default ports Optional[List[str]] list of container exposed ports required Source code in testcompose/containers/container_builder.py def with_exposed_ports ( self , ports : Optional [ List [ str ]]): \"\"\"List of exposed port to be assigned random port numbers on the host. Random ports are exposed to the host. A fixed port can be assigned on the host by providing the port in the format **[host_port:container_port]** Args: ports (Optional[List[str]]): list of container exposed ports \"\"\" if ports : for port in ports : _ports = str ( port ) . split ( \":\" ) if len ( _ports ) == 2 : self . _ports [ int ( _ports [ 1 ])] = int ( _ports [ 0 ]) else : self . _ports [ int ( port )] = None with_volumes ( self , volumes : Optional [ List [ testcompose . models . volume . VolumeMapping ]]) -> None A list of volume mappings to be mounted in the container. !!! volumemapping host: host volume path or a docker volume name container: path to mount the host volume in the container mode: volume mode [ro|rw] Parameters: Name Type Description Default volumes Optional[List[VolumeMapping]] [description] required Source code in testcompose/containers/container_builder.py def with_volumes ( self , volumes : Optional [ List [ VolumeMapping ]]) -> None : \"\"\"A list of volume mappings to be mounted in the container. VolumeMapping: host: host volume path or a docker volume name container: path to mount the host volume in the container mode: volume mode [ro|rw] Args: volumes (Optional[List[VolumeMapping]]): [description] \"\"\" if volumes : for vol in volumes : self . _volumes [ vol . host ] = { \"bind\" : vol . container , \"mode\" : vol . mode } testcompose.containers.container_network.ContainerNetwork Network management for running container.This class ensures all containers in the same test belong to the same network. Contians utility to create and cleanup network. Parameters: Name Type Description Default docker_client DockerClient Docker client required network_name str Name of test network required auto_create_network bool Create network if it doesn't exists. Defaults to False. required container_network : Network property writable Network Object Returns: Type Description Network container network object container_network_id : Optional [ str ] property readonly Container Short Id Returns: Type Description Optional[str] container_id network_name : Optional [ str ] property readonly Network Name Returns: Type Description Optional[str] Network Name get_defined_network ( self , network_name : str , auto_create_network : bool = False ) Identify or create container network Parameters: Name Type Description Default network_name str Network name required auto_create_network bool If set, create network if it does not exists. Defaults to False. False Exceptions: Type Description AttributeError When network does not exist or can not be created. Source code in testcompose/containers/container_network.py def get_defined_network ( self , network_name : str , auto_create_network : bool = False ): \"\"\"Identify or create container network Args: network_name (str): Network name auto_create_network (bool, optional): If set, create network if it does not exists. Defaults to False. Raises: AttributeError: When network does not exist or can not be created. \"\"\" try : networks : List [ Network ] = self . _docker_client . networks . list ( names = [ network_name ]) # type: ignore except Exception : networks = list () if networks : self . container_network = networks [ 0 ] elif not networks and auto_create_network : self . container_network = self . _create_group_network ( network_name ) else : raise AttributeError remove_network ( self ) Cleanup created network Source code in testcompose/containers/container_network.py def remove_network ( self ): \"\"\"Cleanup created network\"\"\" self . container_network . remove () testcompose.containers.generic_container.GenericContainer ( ContainerBuilder ) Generic container object to control the base properties of running containers. This class manipulates the base components of a container. Parameters not part of the ContainerParam object can be provided as keyword arguments. Parameters: Name Type Description Default docker_client DockerClient docker client required container_param ContainerParam container parameter for a given service required container : Container property writable env : Dict [ str , Any ] property writable Container environment variables Returns: Type Description Dict[str, Any] environment variables get_container_attr : RunningContainerAttributes property writable Running container attributes Returns: Type Description RunningContainerAttributes Container attribute object exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ] Execute a command inside a container once it started running. Parameters: Name Type Description Default command Union[str, List[str]] command to run in the container required Exceptions: Type Description RuntimeError when the container object is not set Returns: Type Description Tuple[int, ByteString] A tuple of (exit_code, output) Source code in testcompose/containers/generic_container.py def exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ]: \"\"\"Execute a command inside a container once it started running. Args: command (Union[str, List[str]]): command to run in the container Raises: RuntimeError: when the container object is not set Returns: Tuple[int, ByteString]: A tuple of (exit_code, output) \"\"\" if not self . container : raise RuntimeError ( \"Container must already be running to exec a command\" ) return self . container . exec_run ( cmd = command ) get_container_host_ip () -> str staticmethod The host IP where the container runs Returns: Type Description str host IP Source code in testcompose/containers/generic_container.py @staticmethod def get_container_host_ip () -> str : \"\"\"The host IP where the container runs Returns: str: host IP \"\"\" return socket . gethostbyname ( socket . gethostname ()) get_container_id ( self ) -> Optional [ str ] Container id Returns: Type Description Optional[str] Container Id Source code in testcompose/containers/generic_container.py def get_container_id ( self ) -> Optional [ str ]: \"\"\"Container id Returns: Optional[str]: Container Id \"\"\" if self . container : return self . container . id return None get_container_ip ( self , network_name = 'bridge' ) -> str Running container IP address Parameters: Name Type Description Default network_name [type] [description]. Defaults to NetworkConstants.DEFAULT_NETWORK_MODE. 'bridge' Exceptions: Type Description ValueError when network_name is not provided Returns: Type Description str container IP Address Source code in testcompose/containers/generic_container.py def get_container_ip ( self , network_name = NetworkConstants . DEFAULT_NETWORK_MODE ) -> str : \"\"\"Running container IP address Args: network_name ([type], optional): [description]. Defaults to NetworkConstants.DEFAULT_NETWORK_MODE. Raises: ValueError: when network_name is not provided Returns: str: container IP Address \"\"\" if not network_name : raise ValueError ( \"Docker network name must be provided!!\" ) _networks = self . get_container_attr . NetworkSettings . Networks [ network_name ] return _networks . IPAddress get_exposed_port ( self , port : str ) -> str Get host port bound to the container exposed port Parameters: Name Type Description Default port str container exposed port required Returns: Type Description str Host port bound to the container exposed port Source code in testcompose/containers/generic_container.py def get_exposed_port ( self , port : str ) -> str : \"\"\"Get host port bound to the container exposed port Args: port (str): container exposed port Returns: str: Host port bound to the container exposed port \"\"\" return self . get_mapped_container_ports ([ port ])[ port ] get_mapped_container_ports ( self , ports : List [ str ]) -> Dict [ str , str ] Host port bound to the container returns as a k/v of the container exposed port as key and the host bound port as the value. Parameters: Name Type Description Default ports List[str] List of container exposed port to be mapped to host port required Returns: Type Description Dict[str, str] Mapped container-host ports. Source code in testcompose/containers/generic_container.py def get_mapped_container_ports ( self , ports : List [ str ]) -> Dict [ str , str ]: \"\"\"Host port bound to the container returns as a k/v of the container exposed port as key and the host bound port as the value. Args: ports (List[str]): List of container exposed port to be mapped to host port Returns: Dict[str, str]: Mapped container-host ports. \"\"\" mapped_ports : Dict [ str , str ] = dict () _ports : Dict [ str , Optional [ List [ HostPortMapping ]]] = self . get_container_attr . NetworkSettings . Ports for cport , hport in _ports . items (): host_port = re . sub ( f \"[^0-9]\" , \"\" , cport ) if host_port in ports and hport : mapped_ports . update ({ host_port : str ( hport [ 0 ] . HostPort )}) return mapped_ports reload ( self ) -> None Reload the attributes of a running container Source code in testcompose/containers/generic_container.py def reload ( self ) -> None : \"\"\"Reload the attributes of a running container\"\"\" self . container . reload () self . get_container_attr = RunningContainerAttributes ( ** self . container . attrs ) self . wait_on_condition () search_container_logs ( self , search_string : str , timeout : float = 300.0 , interval : int = 1 ) -> bool Search for a given predicate in the container log. Useful to check if a container is running and healthy Parameters: Name Type Description Default search_string str predicate to search in the log required timeout float Defaults to 300.0. 300.0 interval int Defaults to 1. 1 Exceptions: Type Description ValueError if a non string predicate is passed Returns: Type Description bool True if the log contains the provided predicate Source code in testcompose/containers/generic_container.py def search_container_logs ( self , search_string : str , timeout : float = 300.0 , interval : int = 1 ) -> bool : \"\"\"Search for a given predicate in the container log. Useful to check if a container is running and healthy Args: search_string (str): predicate to search in the log timeout (float, optional): Defaults to 300.0. interval (int, optional): Defaults to 1. Raises: ValueError: if a non string predicate is passed Returns: bool: True if the log contains the provided predicate \"\"\" if not isinstance ( search_string , str ): raise ValueError prog = re . compile ( search_string , re . MULTILINE ) . search start = datetime . now () output : Optional [ Match [ str ]] = None while ( datetime . now () - start ) . total_seconds () < timeout : output = prog ( self . container . logs () . decode ()) if output : return True if ( datetime . now () - start ) . total_seconds () > timeout : return False sleep ( interval ) print ( \" %s \" , self . container . logs () . decode ()) return True if output else False start ( self ) -> None Start a container Source code in testcompose/containers/generic_container.py def start ( self ) -> None : \"\"\"Start a container\"\"\" try : if self . docker_client : self . container = self . docker_client . containers . run ( image = self . generic_container_param . image , command = self . generic_container_param . command , detach = True , environment = self . _environments , ports = self . _ports , volumes = self . _volumes , entrypoint = self . generic_container_param . entry_point , auto_remove = self . generic_container_param . auto_remove , remove = self . generic_container_param . remove_container , ** self . _kwargs , ) self . reload () except Exception as exc : print ( exc ) self . stop () stop ( self , force = True , delete_volume = True ) -> None Stop a running container Parameters: Name Type Description Default force bool [description]. Defaults to True. True delete_volume bool [description]. Defaults to True. True Source code in testcompose/containers/generic_container.py def stop ( self , force = True , delete_volume = True ) -> None : \"\"\"Stop a running container Args: force (bool, optional): [description]. Defaults to True. delete_volume (bool, optional): [description]. Defaults to True. \"\"\" try : if self . container : self . container . remove ( v = delete_volume , force = force ) except APIError as exc : print ( exc ) wait_on_condition ( self , status = 'running' , delay = 0.1 , timeout = 40 ) Method useful for checking a running container status to allow for fetching the latest attribute from the container Parameters: Name Type Description Default status str Status to check for. Defaults to \"running\". 'running' delay float Delay time before the next check. Defaults to 0.1. 0.1 timeout int Defaults to 40. 40 Source code in testcompose/containers/generic_container.py def wait_on_condition ( self , status = \"running\" , delay = 0.1 , timeout = 40 ): \"\"\"Method useful for checking a running container status to allow for fetching the latest attribute from the container Args: status (str, optional): Status to check for. Defaults to \"running\". delay (float, optional): Delay time before the next check. Defaults to 0.1. timeout (int, optional): Defaults to 40. \"\"\" def condition () -> bool : \"\"\"Container emits expected status Returns: bool: container matches expected status \"\"\" return status == self . get_container_attr . State . Status start = datetime . now () while not condition (): if ( datetime . now () - start ) . total_seconds () > timeout : raise AssertionError ( \"Container status %s not obtained after 40secx\" % status ) sleep ( delay ) print ( f \"Found Status { self . get_container_attr . State . Status } \" ) return with_wait_for_http ( self , http_port : str , status_code : int = 200 , end_point : str = '/' , server_startup_time : int = 20 ) -> bool Endpoint health-check for a container. A running service with an exposed endpoint is queried and the response code is checked with the expected response code. Parameters: Name Type Description Default http_port str container service port required status_code int Defaults to 200. 200 end_point str Provided service endpoint. Defaults to \"/\". '/' server_startup_time int Expected wait time for the service to start. Defaults to 20. 20 Returns: Type Description bool Endpoint returned expected status code Source code in testcompose/containers/generic_container.py def with_wait_for_http ( self , http_port : str , status_code : int = 200 , end_point : str = \"/\" , server_startup_time : int = 20 ) -> bool : \"\"\"Endpoint health-check for a container. A running service with an exposed endpoint is queried and the response code is checked with the expected response code. Args: http_port (str): container service port status_code (int, optional): Defaults to 200. end_point (str, optional): Provided service endpoint. Defaults to \"/\". server_startup_time (int, optional): Expected wait time for the service to start. Defaults to 20. Returns: bool: Endpoint returned expected status code \"\"\" response_check : bool = True for _ in range ( 0 , 3 ): sleep ( server_startup_time ) try : site_url = f \"http:// { self . get_container_host_ip () } : { self . get_exposed_port ( port = http_port ) } / { end_point . lstrip ( '/' ) } \" response = get ( url = site_url . rstrip ( \"/\" )) if response . status_code != status_code : print ( \" %s \" , self . container . logs () . decode ()) response_check = False break except Exception as exc : response_check = False print ( \"HTTP_CHECK_ERROE: %s \" , exc ) return response_check","title":"Developer Reference"},{"location":"api/#developer-reference","text":"","title":"Developer Reference"},{"location":"api/#testcompose.client.base_client.BaseClient","text":"","title":"BaseClient"},{"location":"api/#testcompose.client.base_client.BaseClient.docker_client","text":"Docker Client Returns: Type Description DockerClient docker client object","title":"docker_client"},{"location":"api/#testcompose.client.base_client.BaseClient.max_pool_size","text":"","title":"max_pool_size"},{"location":"api/#testcompose.client.base_client.BaseClient.max_timeout","text":"","title":"max_timeout"},{"location":"api/#testcompose.client.base_client.BaseClient.initialise_client","text":"This is the method that initializes the docker client and needs be implemented. Source code in testcompose/client/base_client.py @abstractmethod def initialise_client ( self ) -> None : \"\"\"This is the method that initializes the docker client and needs be implemented. \"\"\" ...","title":"initialise_client()"},{"location":"api/#testcompose.client.client_from_env.EnvClient","text":"","title":"EnvClient"},{"location":"api/#testcompose.client.client_from_env.EnvClient.initialise_client","text":"Init docker client Returns: Type Description DockerClient docker client Source code in testcompose/client/client_from_env.py def initialise_client ( self ) -> None : \"\"\"Init docker client Returns: DockerClient: docker client \"\"\" self . docker_client = docker . from_env ( version = self . _version , timeout = self . _timeout , max_pool_size = self . _max_pool_size , use_ssh_client = self . _use_ssh_client , ssl_version = self . _ssl_version , assert_hostname = self . _assert_hostname , environment = self . _environment , )","title":"initialise_client()"},{"location":"api/#testcompose.client.client_from_url.UrlClient","text":"","title":"UrlClient"},{"location":"api/#testcompose.client.client_from_url.UrlClient.initialise_client","text":"Init docker client Returns: Type Description DockerClient docker client Source code in testcompose/client/client_from_url.py def initialise_client ( self ) -> None : \"\"\"Init docker client Returns: DockerClient: docker client \"\"\" self . docker_client = DockerClient ( base_url = self . _docker_host , version = self . _version , timeout = self . _timeout , tls = self . _tls , user_agent = self . _user_agent , credstor_env = self . _credstor_env , use_ssh_client = self . _use_ssh_client , max_pool_size = self . _max_pool_size , )","title":"initialise_client()"},{"location":"api/#testcompose.configs.parse_config.TestConfigParser","text":"","title":"TestConfigParser"},{"location":"api/#testcompose.configs.parse_config.TestConfigParser.parse_config","text":"parses and verifies test yaml config file Parameters: Name Type Description Default file_name str absolutel path of the config file required Exceptions: Type Description FileNotFoundError when config file not present AttributeError when config file is empty Returns: Type Description ITestConfig A ITestConfig object with all named services in the config Source code in testcompose/configs/parse_config.py @classmethod def parse_config ( cls , file_name : str ) -> ITestConfig : \"\"\"parses and verifies test yaml config file Args: file_name (str): absolutel path of the config file Raises: FileNotFoundError: when config file not present AttributeError: when config file is empty Returns: ITestConfig: A ITestConfig object with all named services in the config \"\"\" if not os . path . exists ( file_name ): raise FileNotFoundError ( f \"Config file { file_name } does not exist!!\" ) content : Dict [ str , Any ] = dict () with open ( file_name , 'r' ) as fh : content = yaml . safe_load ( fh ) if not content : raise AttributeError ( f \"Config content can not be empty\" ) test_services : ITestConfig = ITestConfig ( ** content ) return test_services","title":"parse_config()"},{"location":"api/#testcompose.configs.service_config.Config","text":"This class consumes the model created from a config file. This is an important class that sets the precedence of how the different containers are to be started and stopped. Usually, the precedence are set correctly if the depends_on parameter of the config is set. Cyclic dependency will fail the test before it starts. Parameters: Name Type Description Default test_services ITestConfig model resulting from a parsed configuration file. required","title":"Config"},{"location":"api/#testcompose.configs.service_config.Config.ranked_itest_config_services","text":"Object containing the ordered services from the config Returns: Type Description RankedServices ranked container services","title":"ranked_itest_config_services"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder","text":"Container Builder Parameters: Name Type Description Default ABC [type] required","title":"ContainerBuilder"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.docker_client","text":"Docker Client Returns: Type Description DockerClient client object","title":"docker_client"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.generic_container_param","text":"Container parameter Returns: Type Description ContainerParam parameter model","title":"generic_container_param"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.build","text":"Build container parameters Parameters: Name Type Description Default docker_client DockerClient [description] required Source code in testcompose/containers/container_builder.py def build ( self , docker_client : DockerClient ) -> None : \"\"\"Build container parameters Args: docker_client (DockerClient): [description] \"\"\" self . docker_client = docker_client self . with_environment ( self . _container_param . environment_variables ) self . with_volumes ( self . _container_param . volumes ) self . with_exposed_ports ( self . _container_param . exposed_ports ) if self . generic_container_param . registry_login_param . username : login = self . docker_client . login ( ** self . generic_container_param . registry_login_param . dict ()) print ( login ) print ( f \"Pulling image { self . generic_container_param . image } \" ) self . pull_image ()","title":"build()"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.pull_image","text":"Pull image of registry Pull polic can be one of the following: !!! image_pull_policy - Always_Pull [ default ] - Never Parameters: Name Type Description Default image_pull_policy str Image pull policy for the test. 'Always_Pull' Source code in testcompose/containers/container_builder.py def pull_image ( self , image_pull_policy = \"Always_Pull\" ): \"\"\"Pull image of registry Pull polic can be one of the following: image_pull_policy: - Always_Pull [default] - Never Args: image_pull_policy (str, optional): Image pull policy for the test. \"\"\" # TODO: Allow pull toggle try : self . docker_client . images . get ( name = self . generic_container_param . image ) except ImageNotFound : self . docker_client . images . pull ( repository = self . generic_container_param . image )","title":"pull_image()"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.start","text":"Source code in testcompose/containers/container_builder.py @abstractmethod def start ( self ): ...","title":"start()"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.stop","text":"Source code in testcompose/containers/container_builder.py @abstractmethod def stop ( self ): ...","title":"stop()"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.with_environment","text":"Environment variables for running containers Parameters: Name Type Description Default env Optional[Dict[str, Any]] [description] required Source code in testcompose/containers/container_builder.py def with_environment ( self , env : Optional [ Dict [ str , Any ]]): \"\"\"Environment variables for running containers Args: env (Optional[Dict[str, Any]]): [description] \"\"\" if env : for k , v in env . items (): self . _environments [ k ] = v","title":"with_environment()"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.with_exposed_ports","text":"List of exposed port to be assigned random port numbers on the host. Random ports are exposed to the host. A fixed port can be assigned on the host by providing the port in the format [host_port:container_port] Parameters: Name Type Description Default ports Optional[List[str]] list of container exposed ports required Source code in testcompose/containers/container_builder.py def with_exposed_ports ( self , ports : Optional [ List [ str ]]): \"\"\"List of exposed port to be assigned random port numbers on the host. Random ports are exposed to the host. A fixed port can be assigned on the host by providing the port in the format **[host_port:container_port]** Args: ports (Optional[List[str]]): list of container exposed ports \"\"\" if ports : for port in ports : _ports = str ( port ) . split ( \":\" ) if len ( _ports ) == 2 : self . _ports [ int ( _ports [ 1 ])] = int ( _ports [ 0 ]) else : self . _ports [ int ( port )] = None","title":"with_exposed_ports()"},{"location":"api/#testcompose.containers.container_builder.ContainerBuilder.with_volumes","text":"A list of volume mappings to be mounted in the container. !!! volumemapping host: host volume path or a docker volume name container: path to mount the host volume in the container mode: volume mode [ro|rw] Parameters: Name Type Description Default volumes Optional[List[VolumeMapping]] [description] required Source code in testcompose/containers/container_builder.py def with_volumes ( self , volumes : Optional [ List [ VolumeMapping ]]) -> None : \"\"\"A list of volume mappings to be mounted in the container. VolumeMapping: host: host volume path or a docker volume name container: path to mount the host volume in the container mode: volume mode [ro|rw] Args: volumes (Optional[List[VolumeMapping]]): [description] \"\"\" if volumes : for vol in volumes : self . _volumes [ vol . host ] = { \"bind\" : vol . container , \"mode\" : vol . mode }","title":"with_volumes()"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork","text":"Network management for running container.This class ensures all containers in the same test belong to the same network. Contians utility to create and cleanup network. Parameters: Name Type Description Default docker_client DockerClient Docker client required network_name str Name of test network required auto_create_network bool Create network if it doesn't exists. Defaults to False. required","title":"ContainerNetwork"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.container_network","text":"Network Object Returns: Type Description Network container network object","title":"container_network"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.container_network_id","text":"Container Short Id Returns: Type Description Optional[str] container_id","title":"container_network_id"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.network_name","text":"Network Name Returns: Type Description Optional[str] Network Name","title":"network_name"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.get_defined_network","text":"Identify or create container network Parameters: Name Type Description Default network_name str Network name required auto_create_network bool If set, create network if it does not exists. Defaults to False. False Exceptions: Type Description AttributeError When network does not exist or can not be created. Source code in testcompose/containers/container_network.py def get_defined_network ( self , network_name : str , auto_create_network : bool = False ): \"\"\"Identify or create container network Args: network_name (str): Network name auto_create_network (bool, optional): If set, create network if it does not exists. Defaults to False. Raises: AttributeError: When network does not exist or can not be created. \"\"\" try : networks : List [ Network ] = self . _docker_client . networks . list ( names = [ network_name ]) # type: ignore except Exception : networks = list () if networks : self . container_network = networks [ 0 ] elif not networks and auto_create_network : self . container_network = self . _create_group_network ( network_name ) else : raise AttributeError","title":"get_defined_network()"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.remove_network","text":"Cleanup created network Source code in testcompose/containers/container_network.py def remove_network ( self ): \"\"\"Cleanup created network\"\"\" self . container_network . remove ()","title":"remove_network()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer","text":"Generic container object to control the base properties of running containers. This class manipulates the base components of a container. Parameters not part of the ContainerParam object can be provided as keyword arguments. Parameters: Name Type Description Default docker_client DockerClient docker client required container_param ContainerParam container parameter for a given service required","title":"GenericContainer"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.container","text":"","title":"container"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.env","text":"Container environment variables Returns: Type Description Dict[str, Any] environment variables","title":"env"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_attr","text":"Running container attributes Returns: Type Description RunningContainerAttributes Container attribute object","title":"get_container_attr"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.exe_command","text":"Execute a command inside a container once it started running. Parameters: Name Type Description Default command Union[str, List[str]] command to run in the container required Exceptions: Type Description RuntimeError when the container object is not set Returns: Type Description Tuple[int, ByteString] A tuple of (exit_code, output) Source code in testcompose/containers/generic_container.py def exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ]: \"\"\"Execute a command inside a container once it started running. Args: command (Union[str, List[str]]): command to run in the container Raises: RuntimeError: when the container object is not set Returns: Tuple[int, ByteString]: A tuple of (exit_code, output) \"\"\" if not self . container : raise RuntimeError ( \"Container must already be running to exec a command\" ) return self . container . exec_run ( cmd = command )","title":"exe_command()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_host_ip","text":"The host IP where the container runs Returns: Type Description str host IP Source code in testcompose/containers/generic_container.py @staticmethod def get_container_host_ip () -> str : \"\"\"The host IP where the container runs Returns: str: host IP \"\"\" return socket . gethostbyname ( socket . gethostname ())","title":"get_container_host_ip()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_id","text":"Container id Returns: Type Description Optional[str] Container Id Source code in testcompose/containers/generic_container.py def get_container_id ( self ) -> Optional [ str ]: \"\"\"Container id Returns: Optional[str]: Container Id \"\"\" if self . container : return self . container . id return None","title":"get_container_id()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_ip","text":"Running container IP address Parameters: Name Type Description Default network_name [type] [description]. Defaults to NetworkConstants.DEFAULT_NETWORK_MODE. 'bridge' Exceptions: Type Description ValueError when network_name is not provided Returns: Type Description str container IP Address Source code in testcompose/containers/generic_container.py def get_container_ip ( self , network_name = NetworkConstants . DEFAULT_NETWORK_MODE ) -> str : \"\"\"Running container IP address Args: network_name ([type], optional): [description]. Defaults to NetworkConstants.DEFAULT_NETWORK_MODE. Raises: ValueError: when network_name is not provided Returns: str: container IP Address \"\"\" if not network_name : raise ValueError ( \"Docker network name must be provided!!\" ) _networks = self . get_container_attr . NetworkSettings . Networks [ network_name ] return _networks . IPAddress","title":"get_container_ip()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_exposed_port","text":"Get host port bound to the container exposed port Parameters: Name Type Description Default port str container exposed port required Returns: Type Description str Host port bound to the container exposed port Source code in testcompose/containers/generic_container.py def get_exposed_port ( self , port : str ) -> str : \"\"\"Get host port bound to the container exposed port Args: port (str): container exposed port Returns: str: Host port bound to the container exposed port \"\"\" return self . get_mapped_container_ports ([ port ])[ port ]","title":"get_exposed_port()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_mapped_container_ports","text":"Host port bound to the container returns as a k/v of the container exposed port as key and the host bound port as the value. Parameters: Name Type Description Default ports List[str] List of container exposed port to be mapped to host port required Returns: Type Description Dict[str, str] Mapped container-host ports. Source code in testcompose/containers/generic_container.py def get_mapped_container_ports ( self , ports : List [ str ]) -> Dict [ str , str ]: \"\"\"Host port bound to the container returns as a k/v of the container exposed port as key and the host bound port as the value. Args: ports (List[str]): List of container exposed port to be mapped to host port Returns: Dict[str, str]: Mapped container-host ports. \"\"\" mapped_ports : Dict [ str , str ] = dict () _ports : Dict [ str , Optional [ List [ HostPortMapping ]]] = self . get_container_attr . NetworkSettings . Ports for cport , hport in _ports . items (): host_port = re . sub ( f \"[^0-9]\" , \"\" , cport ) if host_port in ports and hport : mapped_ports . update ({ host_port : str ( hport [ 0 ] . HostPort )}) return mapped_ports","title":"get_mapped_container_ports()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.reload","text":"Reload the attributes of a running container Source code in testcompose/containers/generic_container.py def reload ( self ) -> None : \"\"\"Reload the attributes of a running container\"\"\" self . container . reload () self . get_container_attr = RunningContainerAttributes ( ** self . container . attrs ) self . wait_on_condition ()","title":"reload()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.search_container_logs","text":"Search for a given predicate in the container log. Useful to check if a container is running and healthy Parameters: Name Type Description Default search_string str predicate to search in the log required timeout float Defaults to 300.0. 300.0 interval int Defaults to 1. 1 Exceptions: Type Description ValueError if a non string predicate is passed Returns: Type Description bool True if the log contains the provided predicate Source code in testcompose/containers/generic_container.py def search_container_logs ( self , search_string : str , timeout : float = 300.0 , interval : int = 1 ) -> bool : \"\"\"Search for a given predicate in the container log. Useful to check if a container is running and healthy Args: search_string (str): predicate to search in the log timeout (float, optional): Defaults to 300.0. interval (int, optional): Defaults to 1. Raises: ValueError: if a non string predicate is passed Returns: bool: True if the log contains the provided predicate \"\"\" if not isinstance ( search_string , str ): raise ValueError prog = re . compile ( search_string , re . MULTILINE ) . search start = datetime . now () output : Optional [ Match [ str ]] = None while ( datetime . now () - start ) . total_seconds () < timeout : output = prog ( self . container . logs () . decode ()) if output : return True if ( datetime . now () - start ) . total_seconds () > timeout : return False sleep ( interval ) print ( \" %s \" , self . container . logs () . decode ()) return True if output else False","title":"search_container_logs()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.start","text":"Start a container Source code in testcompose/containers/generic_container.py def start ( self ) -> None : \"\"\"Start a container\"\"\" try : if self . docker_client : self . container = self . docker_client . containers . run ( image = self . generic_container_param . image , command = self . generic_container_param . command , detach = True , environment = self . _environments , ports = self . _ports , volumes = self . _volumes , entrypoint = self . generic_container_param . entry_point , auto_remove = self . generic_container_param . auto_remove , remove = self . generic_container_param . remove_container , ** self . _kwargs , ) self . reload () except Exception as exc : print ( exc ) self . stop ()","title":"start()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.stop","text":"Stop a running container Parameters: Name Type Description Default force bool [description]. Defaults to True. True delete_volume bool [description]. Defaults to True. True Source code in testcompose/containers/generic_container.py def stop ( self , force = True , delete_volume = True ) -> None : \"\"\"Stop a running container Args: force (bool, optional): [description]. Defaults to True. delete_volume (bool, optional): [description]. Defaults to True. \"\"\" try : if self . container : self . container . remove ( v = delete_volume , force = force ) except APIError as exc : print ( exc )","title":"stop()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.wait_on_condition","text":"Method useful for checking a running container status to allow for fetching the latest attribute from the container Parameters: Name Type Description Default status str Status to check for. Defaults to \"running\". 'running' delay float Delay time before the next check. Defaults to 0.1. 0.1 timeout int Defaults to 40. 40 Source code in testcompose/containers/generic_container.py def wait_on_condition ( self , status = \"running\" , delay = 0.1 , timeout = 40 ): \"\"\"Method useful for checking a running container status to allow for fetching the latest attribute from the container Args: status (str, optional): Status to check for. Defaults to \"running\". delay (float, optional): Delay time before the next check. Defaults to 0.1. timeout (int, optional): Defaults to 40. \"\"\" def condition () -> bool : \"\"\"Container emits expected status Returns: bool: container matches expected status \"\"\" return status == self . get_container_attr . State . Status start = datetime . now () while not condition (): if ( datetime . now () - start ) . total_seconds () > timeout : raise AssertionError ( \"Container status %s not obtained after 40secx\" % status ) sleep ( delay ) print ( f \"Found Status { self . get_container_attr . State . Status } \" ) return","title":"wait_on_condition()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.with_wait_for_http","text":"Endpoint health-check for a container. A running service with an exposed endpoint is queried and the response code is checked with the expected response code. Parameters: Name Type Description Default http_port str container service port required status_code int Defaults to 200. 200 end_point str Provided service endpoint. Defaults to \"/\". '/' server_startup_time int Expected wait time for the service to start. Defaults to 20. 20 Returns: Type Description bool Endpoint returned expected status code Source code in testcompose/containers/generic_container.py def with_wait_for_http ( self , http_port : str , status_code : int = 200 , end_point : str = \"/\" , server_startup_time : int = 20 ) -> bool : \"\"\"Endpoint health-check for a container. A running service with an exposed endpoint is queried and the response code is checked with the expected response code. Args: http_port (str): container service port status_code (int, optional): Defaults to 200. end_point (str, optional): Provided service endpoint. Defaults to \"/\". server_startup_time (int, optional): Expected wait time for the service to start. Defaults to 20. Returns: bool: Endpoint returned expected status code \"\"\" response_check : bool = True for _ in range ( 0 , 3 ): sleep ( server_startup_time ) try : site_url = f \"http:// { self . get_container_host_ip () } : { self . get_exposed_port ( port = http_port ) } / { end_point . lstrip ( '/' ) } \" response = get ( url = site_url . rstrip ( \"/\" )) if response . status_code != status_code : print ( \" %s \" , self . container . logs () . decode ()) response_check = False break except Exception as exc : response_check = False print ( \"HTTP_CHECK_ERROE: %s \" , exc ) return response_check","title":"with_wait_for_http()"},{"location":"environment_variables/","text":"Environment Variables These are generally variables exposed on a running container as environment variables. The can be specified in the configuration as: ... environment : SOMEKEY_1 : some_value_1 SOMEKEY_2 : some_value_2 SOMEKEY_3 : some_value_3 ... The above variables SOMEKEY_1 , SOMEKEY_2 and SOMEKEY_3 will be available from within the container as environment variables. Place holder variables from another container can also be used in a container as environment variables as long as the container looking to expose such variables depends on the other contnainer. i.e services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${app1.somekey_app1_1}-${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 The above placeholder variable http://${app1.somekey_app1_1}:${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592 of app2 will be translated at runtime as http://localhost-postgres/localtest:5592 . A primary requirement of this is that app2 depends on app1 !. Extra Environment Variables The following extra environment variables are included in all running containers regardless of whether they container environment variables of their own or not. These variables are: DOCKER_PYTHON_EXTERNAL_HOST : This special variable exposes the hostname of the contianer host. This is of two variations DOCKER_PYTHON_EXTERNAL_HOST_SERVICE_NAME shows the hostname of the container host that a certain container depends on. i.e if container A with service name SERVICE_NAME_A deppends on container B with service name SERVICE_NAME_B , container A will container the extra variable DOCKER_PYTHON_EXTERNAL_HOST_SERVICE_NAME_B and another for itself named DOCKER_PYTHON_EXTERNAL_HOST . In most cases these two values will be the same, except for cases where both containers are running on separate hosts. DOCKER_PYTHON_INTERNAL_HOST : This variable adds the container hostname as an environment variable. This value is usually derived after a container is successfully started. It is useful especially in situation where another container depending on this container requires this containers hostname for a given operation. I.e for two containers A and B with service names SERVICE_NAME_A and SERVICE_NAME_B respectively with A depending on B , A will have an extra environment variable DOCKER_PYTHON_INTERNAL_HOST_SERVICE_NAME_B so as to be able to reference the service running in container B . DOCKER_PYTHON_MAPPED_PORTS : This follows the same principle as the DOCKER_PYTHON_EXTERNAL_HOST where for two containers A and B with service names SERVICE_NAME_A and SERVICE_NAME_B respectively with A depending on B . Then the container A will have the following extra environment variables DOCKER_PYTHON_MAPPED_PORTS_SERVICE_NAME_B and DOCKER_PYTHON_MAPPED_PORTS . While container B will have only DOCKER_PYTHON_MAPPED_PORTS . To use this set of variables, the yaml config above could be extended as shown: services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${app1.docker_python_internal_host}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 And this will be translated as http://${app1.docker_python_internal_host}/${app1.somekey_app1_3}:5592 -> http://app1-runtimehostname/localtest:5592 . Where app1-runtimehostname is determined at runtime. Using self Variables Sometimes, a given service running in a container will require variables that can only be set at service start time. i.e the container must already be running to be able to obtain the real value of such variable. These set of variables are referred to as the self container variables. They can only be used with the following conditions: Only for the current container internal usage. This can not be referenced by another container which depends on this container. This only allows for the variables hostname and host ports denoted as self.hostname and self.hostport_xxxx respectively. Note that the host port variable are for services whose attached host ports are only determined ones the service is started but is required as part of the configuration. To use the self variables, the yaml config above could be extended as shown: services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${self.hostname}/${app1.somekey_app1_3}:${self.hostport_4450}\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 The self.hostname and self.hostport_4450 replacement can only be determined at runtime. Note the 4450 with the host variable. This is because only host port attached to a container exposed port can be deduced. Using a none exposed port for this will result in an error.","title":"Environment Variables"},{"location":"environment_variables/#environment-variables","text":"These are generally variables exposed on a running container as environment variables. The can be specified in the configuration as: ... environment : SOMEKEY_1 : some_value_1 SOMEKEY_2 : some_value_2 SOMEKEY_3 : some_value_3 ... The above variables SOMEKEY_1 , SOMEKEY_2 and SOMEKEY_3 will be available from within the container as environment variables. Place holder variables from another container can also be used in a container as environment variables as long as the container looking to expose such variables depends on the other contnainer. i.e services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${app1.somekey_app1_1}-${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 The above placeholder variable http://${app1.somekey_app1_1}:${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592 of app2 will be translated at runtime as http://localhost-postgres/localtest:5592 . A primary requirement of this is that app2 depends on app1 !.","title":"Environment Variables"},{"location":"environment_variables/#extra-environment-variables","text":"The following extra environment variables are included in all running containers regardless of whether they container environment variables of their own or not. These variables are: DOCKER_PYTHON_EXTERNAL_HOST : This special variable exposes the hostname of the contianer host. This is of two variations DOCKER_PYTHON_EXTERNAL_HOST_SERVICE_NAME shows the hostname of the container host that a certain container depends on. i.e if container A with service name SERVICE_NAME_A deppends on container B with service name SERVICE_NAME_B , container A will container the extra variable DOCKER_PYTHON_EXTERNAL_HOST_SERVICE_NAME_B and another for itself named DOCKER_PYTHON_EXTERNAL_HOST . In most cases these two values will be the same, except for cases where both containers are running on separate hosts. DOCKER_PYTHON_INTERNAL_HOST : This variable adds the container hostname as an environment variable. This value is usually derived after a container is successfully started. It is useful especially in situation where another container depending on this container requires this containers hostname for a given operation. I.e for two containers A and B with service names SERVICE_NAME_A and SERVICE_NAME_B respectively with A depending on B , A will have an extra environment variable DOCKER_PYTHON_INTERNAL_HOST_SERVICE_NAME_B so as to be able to reference the service running in container B . DOCKER_PYTHON_MAPPED_PORTS : This follows the same principle as the DOCKER_PYTHON_EXTERNAL_HOST where for two containers A and B with service names SERVICE_NAME_A and SERVICE_NAME_B respectively with A depending on B . Then the container A will have the following extra environment variables DOCKER_PYTHON_MAPPED_PORTS_SERVICE_NAME_B and DOCKER_PYTHON_MAPPED_PORTS . While container B will have only DOCKER_PYTHON_MAPPED_PORTS . To use this set of variables, the yaml config above could be extended as shown: services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${app1.docker_python_internal_host}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 And this will be translated as http://${app1.docker_python_internal_host}/${app1.somekey_app1_3}:5592 -> http://app1-runtimehostname/localtest:5592 . Where app1-runtimehostname is determined at runtime.","title":"Extra Environment Variables"},{"location":"environment_variables/#using-self-variables","text":"Sometimes, a given service running in a container will require variables that can only be set at service start time. i.e the container must already be running to be able to obtain the real value of such variable. These set of variables are referred to as the self container variables. They can only be used with the following conditions: Only for the current container internal usage. This can not be referenced by another container which depends on this container. This only allows for the variables hostname and host ports denoted as self.hostname and self.hostport_xxxx respectively. Note that the host port variable are for services whose attached host ports are only determined ones the service is started but is required as part of the configuration. To use the self variables, the yaml config above could be extended as shown: services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${self.hostname}/${app1.somekey_app1_3}:${self.hostport_4450}\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 The self.hostname and self.hostport_4450 replacement can only be determined at runtime. Note the 4450 with the host variable. This is because only host port attached to a container exposed port can be deduced. Using a none exposed port for this will result in an error.","title":"Using self Variables"},{"location":"quickstart/","text":"QuickStart Create a config object from a dict. See examples here from testcompose.configs.service_config import Config run_config = Config ( test_services = ITestConfig ( ** config )) Or from a yaml file. Example here from testcompose.configs.parse_config import TestConfigParser config = TestConfigParser . parse_config ( file_name = 'some-config.yaml' ) run_config = Config ( test_services = ITestConfig ( ** config )) Then let's run the containers and do some work with RunContainers ( services = run_config . ranked_itest_config_services ) as runner : assert runner . containers # do or pretend to do some work app_container_srv_name = \"application\" app_env_vars = runner . extra_envs [ app_container_srv_name ] mapped_port = app_env_vars . get ( \"DOCKER_PYTHON_MAPPED_PORTS\" , {}) . get ( \"8000\" ) app_host = app_env_vars . get ( \"DOCKER_PYTHON_EXTERNAL_HOST\" ) response = get ( url = f \"http:// { app_host } : { int ( mapped_port ) } /version\" ) print ( response ) and Voila !!! you are all set !","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"Create a config object from a dict. See examples here from testcompose.configs.service_config import Config run_config = Config ( test_services = ITestConfig ( ** config )) Or from a yaml file. Example here from testcompose.configs.parse_config import TestConfigParser config = TestConfigParser . parse_config ( file_name = 'some-config.yaml' ) run_config = Config ( test_services = ITestConfig ( ** config )) Then let's run the containers and do some work with RunContainers ( services = run_config . ranked_itest_config_services ) as runner : assert runner . containers # do or pretend to do some work app_container_srv_name = \"application\" app_env_vars = runner . extra_envs [ app_container_srv_name ] mapped_port = app_env_vars . get ( \"DOCKER_PYTHON_MAPPED_PORTS\" , {}) . get ( \"8000\" ) app_host = app_env_vars . get ( \"DOCKER_PYTHON_EXTERNAL_HOST\" ) response = get ( url = f \"http:// { app_host } : { int ( mapped_port ) } /version\" ) print ( response ) and Voila !!! you are all set !","title":"QuickStart"}]}