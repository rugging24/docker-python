{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Testcompose Testcompose provides an easy way of using docker containers for functional and integration testing. It allows for combination of more than one containers and allows for interactions with these containers from your test code without having to write extra scripts for such interactions. I.e providing a docker compose kind of functionality with the extra benefit of being able to fully control the containers from test codes. This is inspired by the testcontainers-python project and goes further to add a few additional functionalities to improve software integration testing while allowing the engineer to control every aspect of the test. Install testcompose using pip: $ pip install testcompose testcompose requires Python 3.7+. You can either use a config file of the format: services : - name : db1 image : \"postgres:13\" command : \"\" environment : POSTGRES_USER : postgres POSTGRES_DB : postgres POSTGRES_PASSWORD : password exposed_ports : - 5432 volumes : - host : \"data_volume\" container : \"/data\" mode : \"rw\" source : \"dockervolume\" # possible values are `dockervolume` or `filesystem` log_wait_parameters : log_line_regex : \"database system is ready to accept connections\" wait_timeout_ms : 30 poll_interval_ms : 2 Verify it as follows: from testcompose.parse_config import TestConfigParser from testcompose.configs.service_config import Config from testcompose.run_containers import RunContainers from testcompose.models.config.config_services import ConfigServices , Service my_test_service : ConfigServices = TestConfigParser . parse_config ( file_name = 'some-file-name' ) my_config : Config = Config ( test_services = my_test_service ) with RunContainers ( services = running_config . ranked_itest_config_services ) as runner : # Interract with the running containers assert runner . running_containers # Use some special parameters of the running containers app_container = runner . running_containers [ \"app_container_config_name\" ] . config_environment_variables # Get the host port a certain exposed container port is mapped to mapped_port = app_container . generic_container . get_exposed_port ( \"8000\" ) # where `port` is the exposed port of the container Documentation For a run-through of all the basics, head over to the QuickStart . The Developer Interface provides a comprehensive API reference.","title":"Introduction"},{"location":"#documentation","text":"For a run-through of all the basics, head over to the QuickStart . The Developer Interface provides a comprehensive API reference.","title":"Documentation"},{"location":"api/","text":"Developer Reference testcompose.client.base_docker_client.BaseDockerClient ( ABC ) Source code in testcompose/client/base_docker_client.py class BaseDockerClient ( ABC ): max_timeout = DEFAULT_TIMEOUT_SECONDS max_pool_size = DEFAULT_MAX_POOL_SIZE @property def docker_client ( self ) -> DockerClient : \"\"\"Docker Client Returns: DockerClient: docker client object \"\"\" return self . _docker_client @docker_client . setter def docker_client ( self , client : DockerClient ) -> None : self . _docker_client = client def initialise_docker_client ( self , client_env_param : ClientFromEnv = ClientFromEnv (), client_url_param : ClientFromUrl = ClientFromUrl (), ) -> None : if client_url_param . docker_host : self . docker_client = self . _docker_client_from_url ( client_url_param ) else : self . docker_client = self . _docker_client_from_env ( client_env_param ) self . docker_client . ping () def _docker_client_from_env ( self , client_env_param : ClientFromEnv ) -> DockerClient : return docker . from_env ( version = client_env_param . version , timeout = client_env_param . timeout or BaseDockerClient . max_timeout , max_pool_size = client_env_param . max_pool_size or BaseDockerClient . max_pool_size , use_ssh_client = client_env_param . use_ssh_client , ssl_version = client_env_param . ssl_version , assert_hostname = client_env_param . assert_hostname , environment = client_env_param . environment , ) def _docker_client_from_url ( self , client_url_param : ClientFromUrl ) -> DockerClient : return DockerClient ( base_url = client_url_param . docker_host , version = client_url_param . version , timeout = client_url_param . timeout , tls = client_url_param . tls , user_agent = client_url_param . user_agent , credstor_env = client_url_param . credstor_env , use_ssh_client = client_url_param . use_ssh_client , max_pool_size = client_url_param . max_pool_size , ) docker_client : DockerClient property writable Docker Client Returns: Type Description DockerClient docker client object max_pool_size max_timeout initialise_docker_client ( self , client_env_param : ClientFromEnv = ClientFromEnv ( version = 'auto' , timeout = None , max_pool_size = None , use_ssh_client = False , ssl_version = None , assert_hostname = None , environment = None ), client_url_param : ClientFromUrl = ClientFromUrl ( docker_host = None , version = 'auto' , timeout = None , tls = None , user_agent = None , credstor_env = None , use_ssh_client = None , max_pool_size = None )) -> None Source code in testcompose/client/base_docker_client.py def initialise_docker_client ( self , client_env_param : ClientFromEnv = ClientFromEnv (), client_url_param : ClientFromUrl = ClientFromUrl (), ) -> None : if client_url_param . docker_host : self . docker_client = self . _docker_client_from_url ( client_url_param ) else : self . docker_client = self . _docker_client_from_env ( client_env_param ) self . docker_client . ping () testcompose.configs.parse_config.TestConfigParser Source code in testcompose/configs/parse_config.py class TestConfigParser : @classmethod def parse_config ( cls , file_name : str ) -> ConfigServices : \"\"\"parses and verifies test yaml config file Args: file_name (str): absolutel path of the config file Raises: FileNotFoundError: when config file not present AttributeError: when config file is empty Returns: ConfigServices: A ConfigServices object with all named services in the config \"\"\" if not os . path . exists ( file_name ): raise FileNotFoundError ( f \"Config file { file_name } does not exist!!\" ) contents : Dict [ str , Any ] = dict () with open ( file_name , 'r' ) as fh : contents = yaml . safe_load ( fh ) if not contents : raise AttributeError ( f \"Config content can not be empty\" ) services : Dict [ str , Service ] = dict () for service in contents [ \"services\" ]: services . update ({ service [ \"name\" ]: Service ( ** service )}) test_services : ConfigServices = ConfigServices ( services = services ) return test_services parse_config ( file_name : str ) -> ConfigServices classmethod parses and verifies test yaml config file Parameters: Name Type Description Default file_name str absolutel path of the config file required Exceptions: Type Description FileNotFoundError when config file not present AttributeError when config file is empty Returns: Type Description ConfigServices A ConfigServices object with all named services in the config Source code in testcompose/configs/parse_config.py @classmethod def parse_config ( cls , file_name : str ) -> ConfigServices : \"\"\"parses and verifies test yaml config file Args: file_name (str): absolutel path of the config file Raises: FileNotFoundError: when config file not present AttributeError: when config file is empty Returns: ConfigServices: A ConfigServices object with all named services in the config \"\"\" if not os . path . exists ( file_name ): raise FileNotFoundError ( f \"Config file { file_name } does not exist!!\" ) contents : Dict [ str , Any ] = dict () with open ( file_name , 'r' ) as fh : contents = yaml . safe_load ( fh ) if not contents : raise AttributeError ( f \"Config content can not be empty\" ) services : Dict [ str , Service ] = dict () for service in contents [ \"services\" ]: services . update ({ service [ \"name\" ]: Service ( ** service )}) test_services : ConfigServices = ConfigServices ( services = services ) return test_services testcompose.configs.service_config.Config This class consumes the model created from a config file. This is an important class that sets the precedence of how the different containers are to be started and stopped. Usually, the precedence are set correctly if the depends_on parameter of the config is set. Cyclic dependency will fail the test before it starts. Parameters: Name Type Description Default test_services ConfigServices model resulting from a parsed configuration file. required Source code in testcompose/configs/service_config.py class Config : \"\"\"This class consumes the model created from a config file. This is an important class that sets the precedence of how the different containers are to be started and stopped. Usually, the precedence are set correctly if the `depends_on` parameter of the config is set. Cyclic dependency will fail the test before it starts. Args: test_services (ConfigServices): model resulting from a parsed configuration file. \"\"\" def __init__ ( self , test_services : ConfigServices ) -> None : self . _rank_test_services ( test_services ) @property def ranked_config_services ( self ) -> RankedConfigServices : \"\"\"Object containing the ordered services from the config Returns: RankedServices: ranked container services \"\"\" return self . _ranked_it_services @ranked_config_services . setter def ranked_config_services ( self , ranked_services : RankedConfigServices ) -> None : self . _ranked_it_services = ranked_services def _rank_test_services ( self , test_services : ConfigServices ) -> None : \"\"\" Args: test_services (ConfigServices): model resulting from a parsed configuration file. Raises: ValueError: raised if test_services is `null` AttributeError: raised if no concreate networking is provided \"\"\" if not test_services : logger . error ( \"Config content can not be Null\" ) raise ValueError if not test_services . services : logger . error ( \"No service was found in the provided config\" ) raise ValueError _processed_containers : Dict [ str , int ] = self . _compute_container_ranks ( ranked_services = dict (), config_services = test_services , ) _processed_containers_reversed : Dict [ int , str ] = { rank : service for service , rank in _processed_containers . items () } self . ranked_config_services = RankedConfigServices ( ranked_services = _processed_containers_reversed ) def _compute_container_ranks ( self , * , ranked_services : Dict [ str , int ], config_services : ConfigServices , ) -> Dict [ str , int ]: \"\"\"The main method that computes the ranking of the services specified in the config. Args: ranked_services (Dict[str, int]): dict container service name and their assigned ranks config_services (ConfigServices): config services generated from the supplied configuration file Raises: AttributeError: raised to prevent empty configuration properties to be passed to this function ValueError: rasied when cyclic dependency is detected Returns: Dict[str, int]: A list of ranked service models. \"\"\" _ranked_services : Dict [ str , int ] = deepcopy ( ranked_services ) if not config_services : raise AttributeError ( \"A valid config for test services must be provided\" ) rank = len ( ranked_services . keys ()) if len ( config_services . services . keys ()) == len ( ranked_services . keys ()): return ranked_services else : services : Dict [ str , Service ] = { x : y for x , y in config_services . services . items () if x not in _ranked_services } for service_name , service in services . items (): if not service . depends_on : _ranked_services . update ({ service_name : rank }) rank += 1 else : if set ( service . depends_on ) . issubset ( _ranked_services . keys () ) and not self . _check_cyclic_dependency ( [ config_services . services [ x ] for x in _ranked_services ], service_name ): _ranked_services . update ({ service_name : rank }) rank += 1 elif not set ( service . depends_on ) . issubset ( list ( config_services . services . keys ())): raise AttributeError ( f \"Invalid service name or dependencies detected: { service_name } <=> { set ( service . depends_on ) } \" ) return self . _compute_container_ranks ( ranked_services = _ranked_services , config_services = config_services ) @staticmethod def _check_cyclic_dependency ( processed_services : List [ Service ], dependent_service_name : str ) -> boolean : for service in processed_services : if set ([ dependent_service_name ]) . issubset ( service . depends_on ): return True return False ranked_config_services : RankedConfigServices property writable Object containing the ordered services from the config Returns: Type Description RankedServices ranked container services testcompose.containers.base_service_container.BaseServiceContainer ( ABC ) Container Builder Source code in testcompose/containers/base_service_container.py class BaseServiceContainer ( ABC ): \"\"\"Container Builder\"\"\" def __init__ ( self , docker_client : DockerClient ) -> None : self . _image : str self . _command : str self . _entry_point : str self . _host_name : str self . _network : str self . _http_waiter : HttpWaitParameter self . _log_waiter : LogWaitParameter self . _registry = Login () self . _environments : Dict [ str , Any ] = dict () self . _ports : Dict [ int , Any ] = dict () self . _volumes : Dict [ str , Dict [ str , str ]] = dict () self . _docker_host : Optional [ str ] = None self . _image_pull_policy = 'ALWAYS_PULL' self . docker_client = docker_client @property def container_environment_variables ( self ) -> Dict [ str , Any ]: return self . _container_environment_variables @container_environment_variables . setter def container_environment_variables ( self , env : Dict [ str , Any ]) -> None : self . _container_environment_variables = deepcopy ( env ) @property def docker_client ( self ) -> DockerClient : \"\"\"Docker Client Returns: DockerClient: client object \"\"\" return self . _docker_client @docker_client . setter def docker_client ( self , client : DockerClient ): self . _docker_client = client def with_service ( self , service : Service , processed_containers_services : Dict [ str , RunningContainer ], network : str ) -> 'BaseServiceContainer' : \"\"\" The initialization method that converts a config service into a Generic Container. It leverages other internal _with methods to assign the complete container properties. Args: service (Service): a config service processed_containers_services (Dict[str, Any]): a dict of a service that had already been initiated and the container is running. network (str): the test network name, to attach all containers to. Returns: BaseServiceContainer \"\"\" self . _with_image ( service . image ) self . _with_command ( service . command ) # type: ignore ( substituted_env_variables , modified_exposed_ports , ) = ContainerUtils . replace_container_config_placeholders ( service_env_variables = service . environment , running_containers = processed_containers_services , service_name = service . name , exposed_ports = service . exposed_ports , ) self . _with_environment ( substituted_env_variables ) self . _with_exposed_ports ( modified_exposed_ports ) self . _with_wait_for_http ( service . http_wait_parameters ) # type: ignore self . _with_volumes ( service . volumes ) self . _with_entry_point ( service . entrypoint ) # type: ignore self . _with_log_waiter ( service . log_wait_parameters ) # type: ignore self . _with_host_name ( service . name ) self . _with_network ( network ) return self def _with_network ( self , network : str ): self . _network = network def _with_log_waiter ( self , waiter : LogWaitParameter ) -> None : self . _log_waiter = waiter def _with_host_name ( self , host : str ) -> None : self . _host_name = host def _with_exposed_ports ( self , ports : Optional [ List [ str ]]) -> None : \"\"\"List of exposed port to be assigned random port numbers on the host. Random ports are exposed to the host. A fixed port can be assigned on the host by providing the port in the format **[host_port:container_port]** Args: ports (Optional[List[str]]): list of container exposed ports \"\"\" if ports : for port in ports : _ports = str ( port ) . split ( \":\" ) if len ( _ports ) == 2 : self . _ports [ int ( _ports [ 1 ])] = int ( _ports [ 0 ]) else : self . _ports [ int ( port )] = None def _with_wait_for_http ( self , wait_parameter : HttpWaitParameter ) -> None : self . _http_waiter = wait_parameter def _with_volumes ( self , volumes : Optional [ List [ VolumeMapping ]]) -> None : \"\"\"A list of volume mappings to be mounted in the container. VolumeMapping: host: host volume path or a docker volume name container: path to mount the host volume in the container mode: volume mode [ro|rw] source: source of the volume [filesystem|dockervolume] filesystem: a file or directory to be mounted dockervolume: a docker volume (existing or to be created) Args: volumes (Optional[List[VolumeMapping]]): Optional list of volumes to mount on the container \"\"\" if volumes : for vol in volumes : host_bind : Optional [ str ] = None if vol . source == VolumeSourceTypes . DOCKER_VOLUME_SOURCE : host_bind = vol . host elif vol . source == VolumeSourceTypes . FILESYSTEM_SOURCE : host_bind = str ( pathlib . Path ( vol . host ) . absolute ()) if not host_bind : raise ValueError ( \"Volume source can only be one of local|docker\" ) self . _volumes [ host_bind ] = { \"bind\" : vol . container , \"mode\" : vol . mode } def _with_environment ( self , env : Optional [ Dict [ str , Any ]]) -> None : \"\"\"Environment variables for running containers Args: env (Optional[Dict[str, Any]]): [description] \"\"\" self . container_environment_variables = env or dict () if env : self . _environments = deepcopy ( env ) def _with_image ( self , image : str , image_pull_policy = \"ALWAYS_PULL\" ) -> None : # TODO: Allow pull toggle self . _image = image self . _image_pull_policy = 'ALWAYS_PULL' def _with_command ( self , command : str ) -> None : self . _command = command def with_registry ( self , registry : Login ) -> 'BaseServiceContainer' : self . _registry = registry return self def _with_entry_point ( self , entry_point : str ) -> None : self . _entry_point = entry_point def build ( self ) -> 'BaseServiceContainer' : \"\"\"Construct a Generic container from a config service Args: docker_client (DockerClient): docker client \"\"\" if self . _registry : self . docker_client . login ( ** self . _registry . dict ()) print ( f \"Pulling image { self . _image } \" ) if not self . _image : raise ValueError ( \"A valid Image entity must be provided\" ) try : self . docker_client . images . get ( name = self . _image ) except ImageNotFound : self . docker_client . images . pull ( repository = self . _image ) except Exception : print ( traceback . format_exc ()) return self @abstractmethod def start ( self ) -> None : raise NotImplementedError @abstractmethod def stop ( self , force = True , delete_volume = True ) -> None : raise NotImplementedError container_environment_variables : Dict [ str , Any ] property writable docker_client : DockerClient property writable Docker Client Returns: Type Description DockerClient client object build ( self ) -> BaseServiceContainer Construct a Generic container from a config service Parameters: Name Type Description Default docker_client DockerClient docker client required Source code in testcompose/containers/base_service_container.py def build ( self ) -> 'BaseServiceContainer' : \"\"\"Construct a Generic container from a config service Args: docker_client (DockerClient): docker client \"\"\" if self . _registry : self . docker_client . login ( ** self . _registry . dict ()) print ( f \"Pulling image { self . _image } \" ) if not self . _image : raise ValueError ( \"A valid Image entity must be provided\" ) try : self . docker_client . images . get ( name = self . _image ) except ImageNotFound : self . docker_client . images . pull ( repository = self . _image ) except Exception : print ( traceback . format_exc ()) return self start ( self ) -> None Source code in testcompose/containers/base_service_container.py @abstractmethod def start ( self ) -> None : raise NotImplementedError stop ( self , force = True , delete_volume = True ) -> None Source code in testcompose/containers/base_service_container.py @abstractmethod def stop ( self , force = True , delete_volume = True ) -> None : raise NotImplementedError with_registry ( self , registry : Login ) -> BaseServiceContainer Source code in testcompose/containers/base_service_container.py def with_registry ( self , registry : Login ) -> 'BaseServiceContainer' : self . _registry = registry return self with_service ( self , service : Service , processed_containers_services : Dict [ str , testcompose . models . container . running_container . RunningContainer ], network : str ) -> BaseServiceContainer The initialization method that converts a config service into a Generic Container. It leverages other internal _with methods to assign the complete container properties. Parameters: Name Type Description Default service Service a config service required processed_containers_services Dict[str, Any] a dict of a service that had already been initiated and the container is running. required network str the test network name, to attach all containers to. required Returns: Type Description BaseServiceContainer BaseServiceContainer Source code in testcompose/containers/base_service_container.py def with_service ( self , service : Service , processed_containers_services : Dict [ str , RunningContainer ], network : str ) -> 'BaseServiceContainer' : \"\"\" The initialization method that converts a config service into a Generic Container. It leverages other internal _with methods to assign the complete container properties. Args: service (Service): a config service processed_containers_services (Dict[str, Any]): a dict of a service that had already been initiated and the container is running. network (str): the test network name, to attach all containers to. Returns: BaseServiceContainer \"\"\" self . _with_image ( service . image ) self . _with_command ( service . command ) # type: ignore ( substituted_env_variables , modified_exposed_ports , ) = ContainerUtils . replace_container_config_placeholders ( service_env_variables = service . environment , running_containers = processed_containers_services , service_name = service . name , exposed_ports = service . exposed_ports , ) self . _with_environment ( substituted_env_variables ) self . _with_exposed_ports ( modified_exposed_ports ) self . _with_wait_for_http ( service . http_wait_parameters ) # type: ignore self . _with_volumes ( service . volumes ) self . _with_entry_point ( service . entrypoint ) # type: ignore self . _with_log_waiter ( service . log_wait_parameters ) # type: ignore self . _with_host_name ( service . name ) self . _with_network ( network ) return self testcompose.containers.container_network.ContainerNetwork Network management for running container.This class ensures all containers in the same test belong to the same network. Contians utility to create and cleanup network. Parameters: Name Type Description Default docker_client DockerClient Docker client required network_name str Name of test network required Source code in testcompose/containers/container_network.py class ContainerNetwork : \"\"\"Network management for running container.This class ensures all containers in the same test belong to the same network. Contians utility to create and cleanup network. Args: docker_client (DockerClient): Docker client network_name (str): Name of test network \"\"\" def __init__ ( self , docker_client : DockerClient , network_name : str ) -> None : self . _docker_client = docker_client self . _get_defined_network ( network_name ) @property def container_network ( self ) -> Network : \"\"\"Network Object Returns: docker.models.networks.Network: container network object \"\"\" return self . _container_network @container_network . setter def container_network ( self , network : Network ) -> None : self . _container_network = network @property def network_name ( self ) -> str : \"\"\"Network Name Returns: str: Network Name \"\"\" return self . container_network . name def _get_defined_network ( self , network_name : str ): \"\"\"Identify or create container network Args: network_name (str): Network name Raises: AttributeError: When network does not exist or can not be created. \"\"\" self . container_network = self . _create_group_network ( network_name ) @property def container_network_id ( self ) -> Optional [ str ]: \"\"\"Container Short Id Returns: Optional[str]: container_id \"\"\" return self . container_network . short_id def remove_network ( self ): \"\"\"Cleanup created network\"\"\" if self . container_network . name not in [ 'bridge' , 'none' , 'host' ]: self . container_network . remove () def _create_group_network ( self , network_name : str , label : Dict [ str , str ] = dict (), driver : str = DefaultNeworkDrivers . DEFAULT_BRIDGE_NETWORK , ) -> Network : existing_networks : List [ Network ] = list () try : existing_networks = self . _docker_client . networks . list ( names = [ network_name ]) except Exception : pass if not existing_networks : return self . _docker_client . networks . create ( name = network_name , driver = driver , check_duplicate = True , internal = False , labels = label or None , enable_ipv6 = False , attachable = True , scope = 'local' , ) else : return existing_networks [ 0 ] container_network : Network property writable Network Object Returns: Type Description docker.models.networks.Network container network object container_network_id : Optional [ str ] property readonly Container Short Id Returns: Type Description Optional[str] container_id network_name : str property readonly Network Name Returns: Type Description str Network Name remove_network ( self ) Cleanup created network Source code in testcompose/containers/container_network.py def remove_network ( self ): \"\"\"Cleanup created network\"\"\" if self . container_network . name not in [ 'bridge' , 'none' , 'host' ]: self . container_network . remove () testcompose.containers.container_utils.ContainerUtils Source code in testcompose/containers/container_utils.py class ContainerUtils : @staticmethod def replace_container_config_placeholders ( service_env_variables : Dict [ str , Any ], running_containers : Dict [ str , RunningContainer ], service_name : str , exposed_ports : List [ str ], ) -> Tuple [ Dict [ str , Any ], List [ str ]]: \"\"\"Utility method to replace placeholders in the service containers. Placeholders are usually of the form *${container_name.containerenv_variable}*. Args: service_env_variables (Dict[str, Any]): Dict of config environment variables running_containers Dict[str, RunningContainer]: Running container object service_name (str): service name as specified in the config exposed_ports (List[str]): container exposed ports Raises: ValueError: when a placeholder variable is not of the form service_name.variable_name AttributeError: When a service name could not be found in the list of services obtained from the provided config file. Returns: Tuple[Dict[str, Any], List[str]]: A tuple of `env_config` and `exposed_ports` \"\"\" pattern = \" \\\\ $ \\\\ {([^}]*)}\" substituted_env_variables : Dict [ str , Any ] = copy ( service_env_variables ) modified_exposed_ports = deepcopy ( exposed_ports ) cmpl = re . compile ( pattern = pattern ) . findall for k , v in service_env_variables . items (): if isinstance ( v , str ): replaced_variable = v for occurence in cmpl ( v ): if len ( str ( occurence ) . split ( \".\" )) != 2 : raise ValueError container_name , variable_name = str ( occurence ) . split ( \".\" ) value = None value , _exposed_ports = ContainerUtils . _external_ports_variables ( running_containers , service_name , container_name , variable_name , modified_exposed_ports , ) if _exposed_ports : modified_exposed_ports = deepcopy ( _exposed_ports ) replaced_variable = replaced_variable . replace ( f \"$ {{ { occurence } }} \" , str ( value )) substituted_env_variables [ k ] = replaced_variable return substituted_env_variables , modified_exposed_ports @staticmethod def _get_free_host_port () -> str : \"\"\"Get a free random port number from the container host Returns: str: port number \"\"\" s = socket . socket ( family = socket . AF_INET , type = socket . SOCK_STREAM ) s . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEPORT , 1 ) s . settimeout ( 2 ) s . bind (( \"\" , 0 )) _ , port = s . getsockname () s . close () return port @staticmethod def _external_ports_variables ( running_containers : Dict [ str , RunningContainer ], service_name : str , container_name : str , variable_name : str , exposed_ports : List [ str ] = list (), ): value = None _exposed_ports = list () if container_name . lower () == SupportedPlaceholders . SELF_HOST or variable_name . lower () in [ SupportedPlaceholders . CONTAINER_HOSTNAME , SupportedPlaceholders . EXTERNAL_PORT , SupportedPlaceholders . CONTAINER_HOST_ADDRESS , ]: if ( container_name . lower () == SupportedPlaceholders . SELF_HOST and variable_name . lower () == SupportedPlaceholders . CONTAINER_HOSTNAME ): value = service_name elif ( container_name . lower () != SupportedPlaceholders . SELF_HOST and variable_name . lower () == SupportedPlaceholders . CONTAINER_HOSTNAME ): value = container_name else : if variable_name . lower () . startswith ( SupportedPlaceholders . EXTERNAL_PORT ): value , _exposed_ports = ContainerUtils . _external_port_variables ( variable_name , exposed_ports ) elif variable_name . lower () == SupportedPlaceholders . CONTAINER_HOST_ADDRESS : value = socket . gethostbyname ( socket . gethostname ()) else : value = running_containers [ f \" { container_name . lower () } \" ] . generic_container . container_environment_variables [ f \" { variable_name . upper () } \" ] return value , _exposed_ports @staticmethod def _external_port_variables ( variable_name : str , exposed_ports : List [ str ]): _exposed_ports = deepcopy ( exposed_ports ) container_port = re . sub ( SupportedPlaceholders . EXTERNAL_PORT + \"_\" , \"\" , variable_name ) host_port = ContainerUtils . _get_free_host_port () if container_port and container_port not in exposed_ports : raise AttributeError ( f \"self.hostport_ { container_port } must be a valid supplied exposed_ports value!\" ) _exposed_ports . remove ( container_port ) _exposed_ports . append ( f \" { host_port } : { container_port } \" ) value = str ( host_port ) return value , _exposed_ports replace_container_config_placeholders ( service_env_variables : Dict [ str , Any ], running_containers : Dict [ str , testcompose . models . container . running_container . RunningContainer ], service_name : str , exposed_ports : List [ str ]) -> Tuple [ Dict [ str , Any ], List [ str ]] staticmethod Utility method to replace placeholders in the service containers. Placeholders are usually of the form ${container_name.containerenv_variable} . Parameters: Name Type Description Default service_env_variables Dict[str, Any] Dict of config environment variables required running_containers Dict[str, RunningContainer] Running container object required service_name str service name as specified in the config required exposed_ports List[str] container exposed ports required Exceptions: Type Description ValueError when a placeholder variable is not of the form service_name.variable_name AttributeError When a service name could not be found in the list of services obtained from the provided config file. Returns: Type Description Tuple[Dict[str, Any], List[str]] A tuple of env_config and exposed_ports Source code in testcompose/containers/container_utils.py @staticmethod def replace_container_config_placeholders ( service_env_variables : Dict [ str , Any ], running_containers : Dict [ str , RunningContainer ], service_name : str , exposed_ports : List [ str ], ) -> Tuple [ Dict [ str , Any ], List [ str ]]: \"\"\"Utility method to replace placeholders in the service containers. Placeholders are usually of the form *${container_name.containerenv_variable}*. Args: service_env_variables (Dict[str, Any]): Dict of config environment variables running_containers Dict[str, RunningContainer]: Running container object service_name (str): service name as specified in the config exposed_ports (List[str]): container exposed ports Raises: ValueError: when a placeholder variable is not of the form service_name.variable_name AttributeError: When a service name could not be found in the list of services obtained from the provided config file. Returns: Tuple[Dict[str, Any], List[str]]: A tuple of `env_config` and `exposed_ports` \"\"\" pattern = \" \\\\ $ \\\\ {([^}]*)}\" substituted_env_variables : Dict [ str , Any ] = copy ( service_env_variables ) modified_exposed_ports = deepcopy ( exposed_ports ) cmpl = re . compile ( pattern = pattern ) . findall for k , v in service_env_variables . items (): if isinstance ( v , str ): replaced_variable = v for occurence in cmpl ( v ): if len ( str ( occurence ) . split ( \".\" )) != 2 : raise ValueError container_name , variable_name = str ( occurence ) . split ( \".\" ) value = None value , _exposed_ports = ContainerUtils . _external_ports_variables ( running_containers , service_name , container_name , variable_name , modified_exposed_ports , ) if _exposed_ports : modified_exposed_ports = deepcopy ( _exposed_ports ) replaced_variable = replaced_variable . replace ( f \"$ {{ { occurence } }} \" , str ( value )) substituted_env_variables [ k ] = replaced_variable return substituted_env_variables , modified_exposed_ports testcompose.containers.generic_container.GenericContainer ( BaseServiceContainer ) Generic container object to control the base properties of running containers. This class manipulates the base components of a container. Extra parameters can be provided as keyword arguments. Parameters: Name Type Description Default docker_client DockerClient docker client required Source code in testcompose/containers/generic_container.py class GenericContainer ( BaseServiceContainer ): \"\"\"Generic container object to control the base properties of running containers. This class manipulates the base components of a container. Extra parameters can be provided as keyword arguments. Args: docker_client (DockerClient): docker client \"\"\" def __init__ ( self , docker_client : DockerClient , ** kwargs ) -> None : super () . __init__ ( docker_client ) self . _kwargs = kwargs @property def test_network ( self ) -> ContainerNetwork : return self . _container_network @test_network . setter def test_network ( self , network : ContainerNetwork ) -> None : self . _container_network = network @property def test_container ( self ) -> Container : return self . _container @test_container . setter def test_container ( self , container : Container ) -> None : self . _container = container @property def test_container_attr ( self ) -> RunningContainerAttributes : \"\"\"Running container attributes Returns: RunningContainerAttributes: Container attribute object \"\"\" return self . _container_attr @test_container_attr . setter def test_container_attr ( self , atrr : RunningContainerAttributes ): \"\"\"Running container attributes. Execute reload() to refresh this property. Args: atrr (RunningContainerAttributes): container attributes \"\"\" self . _container_attr = atrr def start ( self ) -> None : \"\"\"Start a container\"\"\" if not self . docker_client . ping (): raise RuntimeError ( \"Docker Client not Running. Please check your docker settings and try again\" ) try : self . test_container = self . docker_client . containers . run ( image = self . _image , command = self . _command , detach = True , environment = self . _environments , ports = self . _ports , volumes = self . _volumes , entrypoint = self . _entry_point , auto_remove = True , remove = True , network = self . _network , hostname = self . _host_name , ** self . _kwargs , ) WaitingUtils . container_status ( self . test_container ) self . reload () LogWaiter . search_container_logs ( self . test_container , self . _log_waiter ) if self . _http_waiter : mapped_http_port : Dict [ str , str ] = dict () mapped_http_port [ str ( self . _http_waiter . http_port )] = self . get_exposed_port ( str ( self . _http_waiter . http_port ) ) EndpointWaiters . wait_for_http ( self . _http_waiter , mapped_http_port ) except Exception as exc : print ( exc ) self . stop () def stop ( self , force = True , delete_volume = True ) -> None : \"\"\"Stop a running container Args: force (bool, optional): [description]. Defaults to True. delete_volume (bool, optional): [description]. Defaults to True. \"\"\" try : if self . test_container : self . test_container . remove ( v = delete_volume , force = force ) except APIError as exc : print ( exc ) def reload ( self ) -> None : \"\"\"Reload the attributes of a running container\"\"\" self . test_container . reload () self . test_container_attr = RunningContainerAttributes ( ** self . test_container . attrs ) if not WaitingUtils . container_status ( self . test_container ): raise RuntimeError ( \"Container could not be started\" ) def get_exposed_port ( self , port : str ) -> str : \"\"\"Get host port bound to the container exposed port Args: port (str): container exposed port Returns: str: Host port bound to the container exposed port \"\"\" if not port : return None # type: ignore return self . _get_mapped_container_ports ([ port ])[ port ] def _get_mapped_container_ports ( self , exposed_ports : List [ str ]) -> Dict [ str , str ]: \"\"\"Host port bound to the container returned as a k/v of the container exposed port as key and the host bound port as the value. Args: ports (List[str]): List of container exposed port to be mapped to host port Returns: Dict[str, str]: Mapped container-host ports. \"\"\" mapped_ports : Dict [ str , str ] = dict () ports : Dict [ str , Any ] = self . test_container_attr . NetworkSettings . Ports # for port in ports : container_port = re . sub ( f \"[^0-9]\" , \"\" , port ) if container_port in exposed_ports and ports [ port ] and isinstance ( ports [ port ], list ): print ( ports , ports [ port ]) host_ports : ContainerMappedPorts = ContainerMappedPorts ( ** ( ports [ port ][ 0 ])) print ( host_ports ) mapped_ports . update ({ container_port : host_ports . HostPort }) return mapped_ports def get_container_id ( self ) -> Optional [ str ]: \"\"\"Container id Returns: Optional[str]: Container Id \"\"\" if self . test_container : return self . test_container . id return None def get_container_host_ip ( self ) -> str : \"\"\"Container Host IP address Returns: str: container host IP Address \"\"\" return socket . gethostbyname ( socket . gethostname ()) def exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ]: \"\"\"Execute a command inside a container once it started running. Args: command (Union[str, List[str]]): command to run in the container Raises: RuntimeError: when the container object is not set Returns: Tuple[int, ByteString]: A tuple of (exit_code, output) \"\"\" if not self . test_container : raise RuntimeError ( \"Container must already be running to exec a command\" ) return self . test_container . exec_run ( cmd = command ) test_container : Container property writable test_container_attr : RunningContainerAttributes property writable Running container attributes Returns: Type Description RunningContainerAttributes Container attribute object test_network : ContainerNetwork property writable exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ] Execute a command inside a container once it started running. Parameters: Name Type Description Default command Union[str, List[str]] command to run in the container required Exceptions: Type Description RuntimeError when the container object is not set Returns: Type Description Tuple[int, ByteString] A tuple of (exit_code, output) Source code in testcompose/containers/generic_container.py def exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ]: \"\"\"Execute a command inside a container once it started running. Args: command (Union[str, List[str]]): command to run in the container Raises: RuntimeError: when the container object is not set Returns: Tuple[int, ByteString]: A tuple of (exit_code, output) \"\"\" if not self . test_container : raise RuntimeError ( \"Container must already be running to exec a command\" ) return self . test_container . exec_run ( cmd = command ) get_container_host_ip ( self ) -> str Container Host IP address Returns: Type Description str container host IP Address Source code in testcompose/containers/generic_container.py def get_container_host_ip ( self ) -> str : \"\"\"Container Host IP address Returns: str: container host IP Address \"\"\" return socket . gethostbyname ( socket . gethostname ()) get_container_id ( self ) -> Optional [ str ] Container id Returns: Type Description Optional[str] Container Id Source code in testcompose/containers/generic_container.py def get_container_id ( self ) -> Optional [ str ]: \"\"\"Container id Returns: Optional[str]: Container Id \"\"\" if self . test_container : return self . test_container . id return None get_exposed_port ( self , port : str ) -> str Get host port bound to the container exposed port Parameters: Name Type Description Default port str container exposed port required Returns: Type Description str Host port bound to the container exposed port Source code in testcompose/containers/generic_container.py def get_exposed_port ( self , port : str ) -> str : \"\"\"Get host port bound to the container exposed port Args: port (str): container exposed port Returns: str: Host port bound to the container exposed port \"\"\" if not port : return None # type: ignore return self . _get_mapped_container_ports ([ port ])[ port ] reload ( self ) -> None Reload the attributes of a running container Source code in testcompose/containers/generic_container.py def reload ( self ) -> None : \"\"\"Reload the attributes of a running container\"\"\" self . test_container . reload () self . test_container_attr = RunningContainerAttributes ( ** self . test_container . attrs ) if not WaitingUtils . container_status ( self . test_container ): raise RuntimeError ( \"Container could not be started\" ) start ( self ) -> None Start a container Source code in testcompose/containers/generic_container.py def start ( self ) -> None : \"\"\"Start a container\"\"\" if not self . docker_client . ping (): raise RuntimeError ( \"Docker Client not Running. Please check your docker settings and try again\" ) try : self . test_container = self . docker_client . containers . run ( image = self . _image , command = self . _command , detach = True , environment = self . _environments , ports = self . _ports , volumes = self . _volumes , entrypoint = self . _entry_point , auto_remove = True , remove = True , network = self . _network , hostname = self . _host_name , ** self . _kwargs , ) WaitingUtils . container_status ( self . test_container ) self . reload () LogWaiter . search_container_logs ( self . test_container , self . _log_waiter ) if self . _http_waiter : mapped_http_port : Dict [ str , str ] = dict () mapped_http_port [ str ( self . _http_waiter . http_port )] = self . get_exposed_port ( str ( self . _http_waiter . http_port ) ) EndpointWaiters . wait_for_http ( self . _http_waiter , mapped_http_port ) except Exception as exc : print ( exc ) self . stop () stop ( self , force = True , delete_volume = True ) -> None Stop a running container Parameters: Name Type Description Default force bool [description]. Defaults to True. True delete_volume bool [description]. Defaults to True. True Source code in testcompose/containers/generic_container.py def stop ( self , force = True , delete_volume = True ) -> None : \"\"\"Stop a running container Args: force (bool, optional): [description]. Defaults to True. delete_volume (bool, optional): [description]. Defaults to True. \"\"\" try : if self . test_container : self . test_container . remove ( v = delete_volume , force = force ) except APIError as exc : print ( exc ) testcompose.containers.supported_placeholders.SupportedPlaceholders dataclass SupportedPlaceholders(SELF_HOST: str = 'self', CONTAINER_HOSTNAME: str = 'container_hostname', EXTERNAL_PORT: str = 'external_port', CONTAINER_HOST_ADDRESS: str = 'container_host_address') Source code in testcompose/containers/supported_placeholders.py @dataclass ( frozen = True ) class SupportedPlaceholders : SELF_HOST : str = 'self' CONTAINER_HOSTNAME : str = 'container_hostname' EXTERNAL_PORT : str = 'external_port' CONTAINER_HOST_ADDRESS : str = 'container_host_address' CONTAINER_HOSTNAME : str dataclass-field CONTAINER_HOST_ADDRESS : str dataclass-field EXTERNAL_PORT : str dataclass-field SELF_HOST : str dataclass-field testcompose.models.client.client_login.ClientFromEnv ( BaseModel ) pydantic-model Source code in testcompose/models/client/client_login.py class ClientFromEnv ( BaseModel ): version : str = \"auto\" timeout : Optional [ int ] = None max_pool_size : Optional [ int ] = None use_ssh_client : bool = False ssl_version : Optional [ int ] = None assert_hostname : Optional [ bool ] = None environment : Optional [ Dict [ str , Any ]] = None assert_hostname : bool pydantic-field environment : Dict [ str , Any ] pydantic-field max_pool_size : int pydantic-field ssl_version : int pydantic-field timeout : int pydantic-field use_ssh_client : bool pydantic-field version : str pydantic-field testcompose.models.client.client_login.ClientFromUrl ( BaseModel ) pydantic-model Source code in testcompose/models/client/client_login.py class ClientFromUrl ( BaseModel ): docker_host : Optional [ str ] = None version : str = \"auto\" timeout : Optional [ int ] = None tls : Optional [ bool ] = None user_agent : Optional [ str ] = None credstor_env : Optional [ Dict [ str , Any ]] = None use_ssh_client : Optional [ bool ] = None max_pool_size : Optional [ int ] = None credstor_env : Dict [ str , Any ] pydantic-field docker_host : str pydantic-field max_pool_size : int pydantic-field timeout : int pydantic-field tls : bool pydantic-field use_ssh_client : bool pydantic-field user_agent : str pydantic-field version : str pydantic-field testcompose.models.client.registry_parameters.Login ( BaseModel ) pydantic-model Source code in testcompose/models/client/registry_parameters.py class Login ( BaseModel ): username : Optional [ str ] = None password : Optional [ str ] = None email : Optional [ str ] = None registry : Optional [ str ] = None reauth : Optional [ bool ] = False dockercfg_path : Optional [ str ] = None dockercfg_path : str pydantic-field email : str pydantic-field password : str pydantic-field reauth : bool pydantic-field registry : str pydantic-field username : str pydantic-field testcompose.models.config.config_services.Service ( BaseModel ) pydantic-model Source code in testcompose/models/config/config_services.py class Service ( BaseModel ): name : str image : str exposed_ports : List [ str ] command : Optional [ str ] = None environment : Dict [ str , Any ] = dict () depends_on : List [ str ] = list () volumes : List [ VolumeMapping ] = list () log_wait_parameters : Optional [ LogWaitParameter ] = None http_wait_parameters : Optional [ HttpWaitParameter ] = None https_wait_parameters : Optional [ HttpWaitParameter ] = None entrypoint : Optional [ str ] = None @validator ( 'name' ) def validate_service_name ( cls , v ): if not v : raise AttributeError ( \"Service name is required\" ) return v @validator ( 'image' ) def validate_image ( cls , v ): if not v : raise AttributeError ( \"A valid image name is required\" ) return v command : str pydantic-field depends_on : List [ str ] pydantic-field entrypoint : str pydantic-field environment : Dict [ str , Any ] pydantic-field exposed_ports : List [ str ] pydantic-field required http_wait_parameters : HttpWaitParameter pydantic-field https_wait_parameters : HttpWaitParameter pydantic-field image : str pydantic-field required log_wait_parameters : LogWaitParameter pydantic-field name : str pydantic-field required volumes : List [ testcompose . models . config . volume . VolumeMapping ] pydantic-field validate_image ( v ) classmethod Source code in testcompose/models/config/config_services.py @validator ( 'image' ) def validate_image ( cls , v ): if not v : raise AttributeError ( \"A valid image name is required\" ) return v validate_service_name ( v ) classmethod Source code in testcompose/models/config/config_services.py @validator ( 'name' ) def validate_service_name ( cls , v ): if not v : raise AttributeError ( \"Service name is required\" ) return v testcompose.models.config.config_services.ConfigServices ( BaseModel ) pydantic-model ConfigServices holds Dict of Service and their names Parameters: Name Type Description Default services Dict[name, Service] required Source code in testcompose/models/config/config_services.py class ConfigServices ( BaseModel ): \"\"\" ConfigServices holds Dict of Service and their names Args: services: Dict[name, Service] \"\"\" services : Dict [ str , Service ] services : Dict [ str , testcompose . models . config . config_services . Service ] pydantic-field required testcompose.models.config.config_services.RankedConfigServices ( BaseModel ) pydantic-model RankedConfigServices holds a dict of services ranked in the order they are to be started. Parameters: Name Type Description Default ranked_services Dict[rank, name] required Source code in testcompose/models/config/config_services.py class RankedConfigServices ( BaseModel ): \"\"\" RankedConfigServices holds a dict of services ranked in the order they are to be started. Args: ranked_services: Dict[rank, name] \"\"\" ranked_services : Dict [ int , str ] = dict () ranked_services : Dict [ int , str ] pydantic-field testcompose.models.config.container_http_wait_parameter.HttpWaitParameter ( BaseModel ) pydantic-model Source code in testcompose/models/config/container_http_wait_parameter.py class HttpWaitParameter ( BaseModel ): http_port : int response_status_code : int = 200 startup_delay_time_ms : int = 20000 end_point : str = '/' use_https : bool = False @validator ( 'http_port' ) def validate_http_port ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer exposed Http port must be provided\" ) return v @validator ( 'end_point' ) def validate_end_point ( cls , v ): if not v or not isinstance ( v , str ): raise AttributeError ( \"A valide Http endpoint must be provided\" ) return v @validator ( 'response_status_code' ) def validate_response_status_code ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer Http response code must be provided\" ) return v @validator ( 'startup_delay_time_ms' ) def validate_startup_delay_time_ms ( cls , v ): if not v or not isinstance ( v , int ): return 20000 return v end_point : str pydantic-field http_port : int pydantic-field required response_status_code : int pydantic-field startup_delay_time_ms : int pydantic-field use_https : bool pydantic-field validate_end_point ( v ) classmethod Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'end_point' ) def validate_end_point ( cls , v ): if not v or not isinstance ( v , str ): raise AttributeError ( \"A valide Http endpoint must be provided\" ) return v validate_http_port ( v ) classmethod Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'http_port' ) def validate_http_port ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer exposed Http port must be provided\" ) return v validate_response_status_code ( v ) classmethod Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'response_status_code' ) def validate_response_status_code ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer Http response code must be provided\" ) return v validate_startup_delay_time_ms ( v ) classmethod Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'startup_delay_time_ms' ) def validate_startup_delay_time_ms ( cls , v ): if not v or not isinstance ( v , int ): return 20000 return v testcompose.models.config.container_log_wait_parameters.LogWaitParameter ( BaseModel ) pydantic-model Source code in testcompose/models/config/container_log_wait_parameters.py class LogWaitParameter ( BaseModel ): log_line_regex : str wait_timeout_ms : int = 60000 poll_interval_ms : int = 10000 @validator ( 'log_line_regex' ) def validate_log_line_regex ( cls , v ): if not v : raise AttributeError ( \"log_line_prefix must be set\" ) return v log_line_regex : str pydantic-field required poll_interval_ms : int pydantic-field wait_timeout_ms : int pydantic-field validate_log_line_regex ( v ) classmethod Source code in testcompose/models/config/container_log_wait_parameters.py @validator ( 'log_line_regex' ) def validate_log_line_regex ( cls , v ): if not v : raise AttributeError ( \"log_line_prefix must be set\" ) return v testcompose.models.config.volume.VolumeSourceTypes dataclass VolumeSourceTypes(FILESYSTEM_SOURCE: str = 'filesystem', DOCKER_VOLUME_SOURCE: str = 'dockervolume') Source code in testcompose/models/config/volume.py @dataclass ( frozen = True ) class VolumeSourceTypes : FILESYSTEM_SOURCE : str = \"filesystem\" DOCKER_VOLUME_SOURCE : str = \"dockervolume\" DOCKER_VOLUME_SOURCE : str dataclass-field FILESYSTEM_SOURCE : str dataclass-field testcompose.models.config.volume.VolumeMapping ( BaseModel ) pydantic-model Source code in testcompose/models/config/volume.py class VolumeMapping ( BaseModel ): host : str container : str mode : str = 'ro' source : str = VolumeSourceTypes . DOCKER_VOLUME_SOURCE @validator ( 'mode' ) def validate_mode ( cls , v ): assert str ( v ) . lower () in [ 'ro' , 'rw' ] return v @validator ( 'source' ) def validate_source ( cls , v ): assert str ( v ) . lower () in [ 'filesystem' , 'dockervolume' ] return v @validator ( 'host' ) def validate_host ( cls , v ): if not v : raise AttributeError ( \"Volume Host option can not be empty or None\" ) return v @validator ( 'container' ) def validate_container ( cls , v ): if not v : raise AttributeError ( \"Volume container option can not be empty or None\" ) return v container : str pydantic-field required host : str pydantic-field required mode : str pydantic-field source : str pydantic-field validate_container ( v ) classmethod Source code in testcompose/models/config/volume.py @validator ( 'container' ) def validate_container ( cls , v ): if not v : raise AttributeError ( \"Volume container option can not be empty or None\" ) return v validate_host ( v ) classmethod Source code in testcompose/models/config/volume.py @validator ( 'host' ) def validate_host ( cls , v ): if not v : raise AttributeError ( \"Volume Host option can not be empty or None\" ) return v validate_mode ( v ) classmethod Source code in testcompose/models/config/volume.py @validator ( 'mode' ) def validate_mode ( cls , v ): assert str ( v ) . lower () in [ 'ro' , 'rw' ] return v validate_source ( v ) classmethod Source code in testcompose/models/config/volume.py @validator ( 'source' ) def validate_source ( cls , v ): assert str ( v ) . lower () in [ 'filesystem' , 'dockervolume' ] return v testcompose.models.container.running_container_attributes.PossibleContainerStates ( Enum ) An enumeration. Source code in testcompose/models/container/running_container_attributes.py class PossibleContainerStates ( Enum ): RUNNING = 'exited' EXITED = 'running' EXITED RUNNING testcompose.models.container.running_container_attributes.ContainerState ( BaseModel ) pydantic-model Source code in testcompose/models/container/running_container_attributes.py class ContainerState ( BaseModel ): Status : str Running : bool Paused : bool Restarting : bool OOMKilled : bool Dead : bool Pid : int ExitCode : int Error : str StartedAt : str FinishedAt : str Dead : bool pydantic-field required Error : str pydantic-field required ExitCode : int pydantic-field required FinishedAt : str pydantic-field required OOMKilled : bool pydantic-field required Paused : bool pydantic-field required Pid : int pydantic-field required Restarting : bool pydantic-field required Running : bool pydantic-field required StartedAt : str pydantic-field required Status : str pydantic-field required testcompose.models.container.running_container_attributes.RunningContainerAttributes ( BaseModel ) pydantic-model Source code in testcompose/models/container/running_container_attributes.py class RunningContainerAttributes ( BaseModel ): Id : str State : ContainerState Platform : str NetworkSettings : ContainerNetworkSettings Id : str pydantic-field required NetworkSettings : ContainerNetworkSettings pydantic-field required Platform : str pydantic-field required State : ContainerState pydantic-field required testcompose.models.network.network.NetworkComponents ( BaseModel ) pydantic-model Source code in testcompose/models/network/network.py class NetworkComponents ( BaseModel ): Aliases : Optional [ List [ str ]] = None NetworkID : str EndpointID : str Gateway : str IPAddress : str Aliases : List [ str ] pydantic-field EndpointID : str pydantic-field required Gateway : str pydantic-field required IPAddress : str pydantic-field required NetworkID : str pydantic-field required testcompose.models.network.network.ContainerMappedPorts ( BaseModel ) pydantic-model Source code in testcompose/models/network/network.py class ContainerMappedPorts ( BaseModel ): HostIp : str HostPort : str HostIp : str pydantic-field required HostPort : str pydantic-field required testcompose.models.network.network.ContainerNetworkSettings ( BaseModel ) pydantic-model Source code in testcompose/models/network/network.py class ContainerNetworkSettings ( BaseModel ): Ports : Dict [ str , Any ] = dict () Networks : Dict [ str , NetworkComponents ] Networks : Dict [ str , testcompose . models . network . network . NetworkComponents ] pydantic-field required Ports : Dict [ str , Any ] pydantic-field testcompose.models.network.network.DefaultNeworkDrivers dataclass DefaultNeworkDrivers() Source code in testcompose/models/network/network.py @dataclass ( frozen = True ) class DefaultNeworkDrivers : DEFAULT_BRIDGE_NETWORK = 'bridge' DEFAULT_HOST_NETWORK = 'host' DEFAULT_NULL_NETWORK = 'null' DEFAULT_BRIDGE_NETWORK DEFAULT_HOST_NETWORK DEFAULT_NULL_NETWORK testcompose.waiters.endpoint_waiters.EndpointWaiters Source code in testcompose/waiters/endpoint_waiters.py class EndpointWaiters : @staticmethod def _get_container_host_ip () -> str : \"\"\"The host IP where the container runs Returns: str: host IP \"\"\" return socket . gethostbyname ( socket . gethostname ()) @staticmethod def _check_endpoint ( wait_parameter : HttpWaitParameter , exposed_ports : Dict [ str , str ]) -> None : \"\"\"Endpoint health-check for a container. A running service with an exposed endpoint is queried and the response code is checked with the expected response code. Args: http_port (str): container service port status_code (int, optional): Defaults to 200. end_point (str, optional): Provided service endpoint. Defaults to \"/\". server_startup_time (int, optional): Expected wait time for the service to start. Defaults to 20. Returns: bool: Endpoint returned expected status code \"\"\" response_check : bool = True site_url : str = \"https://\" if wait_parameter . use_https else \"http://\" for _ in range ( 0 , 3 ): sleep ( wait_parameter . startup_delay_time_ms / 1000 ) try : host = EndpointWaiters . _get_container_host_ip () mapped_port = exposed_ports [ str ( wait_parameter . http_port )] site_url = site_url + f \" { host } : { mapped_port } / { wait_parameter . end_point . lstrip ( '/' ) } \" print ( site_url ) response = get ( url = site_url . rstrip ( \"/\" )) if response . status_code == wait_parameter . response_status_code : break except Exception as exc : response_check = False print ( \"HTTP_CHECK_ERROR: %s \" , exc ) if not response_check : raise RuntimeError ( f \"Http check on port { wait_parameter . http_port } failed\" ) return @staticmethod def wait_for_http ( wait_parameter : HttpWaitParameter , exposed_ports : Dict [ str , str ]) -> None : if wait_parameter : EndpointWaiters . _check_endpoint ( wait_parameter , exposed_ports ) wait_for_http ( wait_parameter : HttpWaitParameter , exposed_ports : Dict [ str , str ]) -> None staticmethod Source code in testcompose/waiters/endpoint_waiters.py @staticmethod def wait_for_http ( wait_parameter : HttpWaitParameter , exposed_ports : Dict [ str , str ]) -> None : if wait_parameter : EndpointWaiters . _check_endpoint ( wait_parameter , exposed_ports ) testcompose.waiters.log_waiters.LogWaiter Source code in testcompose/waiters/log_waiters.py class LogWaiter : @staticmethod def search_container_logs ( test_container : Container , log_parameter : LogWaitParameter ) -> None : \"\"\"Search for a given predicate in the container log. Useful to check if a container is running and healthy Args: search_string (str): predicate to search in the log timeout (float, optional): Defaults to 300.0. interval (int, optional): Defaults to 1. Raises: ValueError: if a non string predicate is passed Returns: bool: True if the log contains the provided predicate \"\"\" if not log_parameter : return if not isinstance ( log_parameter . log_line_regex , str ): raise ValueError prog = re . compile ( log_parameter . log_line_regex , re . MULTILINE ) . search start = datetime . now () output : Optional [ Match [ str ]] = None while ( datetime . now () - start ) . total_seconds () < ( log_parameter . wait_timeout_ms / 1000 ): output = prog ( test_container . logs () . decode ()) if output : return if ( datetime . now () - start ) . total_seconds () > ( log_parameter . wait_timeout_ms / 1000 ): raise TimeoutError ( \"container %s did not emit logs satisfying predicate in %.3f seconds\" % ( test_container . name , float ( log_parameter . wait_timeout_ms or 60000 )) ) sleep ( log_parameter . poll_interval_ms / 1000 ) print ( \" %s \" , test_container . logs () . decode ()) return search_container_logs ( test_container : Container , log_parameter : LogWaitParameter ) -> None staticmethod Search for a given predicate in the container log. Useful to check if a container is running and healthy Parameters: Name Type Description Default search_string str predicate to search in the log required timeout float Defaults to 300.0. required interval int Defaults to 1. required Exceptions: Type Description ValueError if a non string predicate is passed Returns: Type Description bool True if the log contains the provided predicate Source code in testcompose/waiters/log_waiters.py @staticmethod def search_container_logs ( test_container : Container , log_parameter : LogWaitParameter ) -> None : \"\"\"Search for a given predicate in the container log. Useful to check if a container is running and healthy Args: search_string (str): predicate to search in the log timeout (float, optional): Defaults to 300.0. interval (int, optional): Defaults to 1. Raises: ValueError: if a non string predicate is passed Returns: bool: True if the log contains the provided predicate \"\"\" if not log_parameter : return if not isinstance ( log_parameter . log_line_regex , str ): raise ValueError prog = re . compile ( log_parameter . log_line_regex , re . MULTILINE ) . search start = datetime . now () output : Optional [ Match [ str ]] = None while ( datetime . now () - start ) . total_seconds () < ( log_parameter . wait_timeout_ms / 1000 ): output = prog ( test_container . logs () . decode ()) if output : return if ( datetime . now () - start ) . total_seconds () > ( log_parameter . wait_timeout_ms / 1000 ): raise TimeoutError ( \"container %s did not emit logs satisfying predicate in %.3f seconds\" % ( test_container . name , float ( log_parameter . wait_timeout_ms or 60000 )) ) sleep ( log_parameter . poll_interval_ms / 1000 ) print ( \" %s \" , test_container . logs () . decode ()) return testcompose.waiters.waiting_utils.WaitingUtils Source code in testcompose/waiters/waiting_utils.py class WaitingUtils : @staticmethod def container_status ( test_container : Container , status = \"running\" , delay_ms = 2000 , timeout_ms = 40000 ) -> bool : \"\"\"Method useful for checking a running container status to allow for fetching the latest attribute from the container Args: status (str, optional): Status to check for. Defaults to \"running\". delay (float, optional): Delay time before the next check. Defaults to 0.1. timeout (int, optional): Defaults to 40. \"\"\" print ( status ) if status . lower () not in [ PossibleContainerStates . EXITED . value , PossibleContainerStates . RUNNING . value , ]: raise ValueError ( \"Status must be one of running or exited\" ) start = datetime . now () while not ( status == ( RunningContainerAttributes ( ** test_container . attrs )) . State . Status ): if ( datetime . now () - start ) . total_seconds () * 1000 > timeout_ms : print ( f \"Container status { status } not obtained after { timeout_ms } ms\" ) return False sleep ( delay_ms / 1000 ) test_container . reload () print ( f \"Found Status { status } \" ) return True container_status ( test_container : Container , status = 'running' , delay_ms = 2000 , timeout_ms = 40000 ) -> bool staticmethod Method useful for checking a running container status to allow for fetching the latest attribute from the container Parameters: Name Type Description Default status str Status to check for. Defaults to \"running\". 'running' delay float Delay time before the next check. Defaults to 0.1. required timeout int Defaults to 40. required Source code in testcompose/waiters/waiting_utils.py @staticmethod def container_status ( test_container : Container , status = \"running\" , delay_ms = 2000 , timeout_ms = 40000 ) -> bool : \"\"\"Method useful for checking a running container status to allow for fetching the latest attribute from the container Args: status (str, optional): Status to check for. Defaults to \"running\". delay (float, optional): Delay time before the next check. Defaults to 0.1. timeout (int, optional): Defaults to 40. \"\"\" print ( status ) if status . lower () not in [ PossibleContainerStates . EXITED . value , PossibleContainerStates . RUNNING . value , ]: raise ValueError ( \"Status must be one of running or exited\" ) start = datetime . now () while not ( status == ( RunningContainerAttributes ( ** test_container . attrs )) . State . Status ): if ( datetime . now () - start ) . total_seconds () * 1000 > timeout_ms : print ( f \"Container status { status } not obtained after { timeout_ms } ms\" ) return False sleep ( delay_ms / 1000 ) test_container . reload () print ( f \"Found Status { status } \" ) return True testcompose.run_containers.RunContainers ( BaseDockerClient ) Run test containers Parameters: Name Type Description Default services RankedServices Ranked container services to be ran required wait_time_between_container_start float Default time to wait before spawning the next container. This is aimed at preventing starting containers too earlier before the container(s) they depend on has not fully started. Especially when they do not have a log predicate to search for or an http endpoint to check agains. Defaults to 20.0. 20.0 url_param ClientFromUrl Url parameters for connecting to the docker daemon. Defaults to ClientFromUrl(). ClientFromUrl(docker_host=None, version='auto', timeout=None, tls=None, user_agent=None, credstor_env=None, use_ssh_client=None, max_pool_size=None) env_param ClientFromEnv Environment variables parameter required to connect to the docker daemon. Defaults to ClientFromEnv(). ClientFromEnv(version='auto', timeout=None, max_pool_size=None, use_ssh_client=False, ssl_version=None, assert_hostname=None, environment=None) registry_login_param [type] Parameter providing docker registry login details. Defaults to Login(). Login(username=None, password=None, email=None, registry=None, reauth=False, dockercfg_path=None) Source code in testcompose/run_containers.py class RunContainers ( BaseDockerClient ): \"\"\"Run test containers Args: services (RankedServices): Ranked container services to be ran wait_time_between_container_start (float, optional): Default time to wait before spawning the next container. This is aimed at preventing starting containers too earlier before the container(s) they depend on has not fully started. Especially when they do not have a log predicate to search for or an http endpoint to check agains. Defaults to 20.0. url_param (ClientFromUrl, optional): Url parameters for connecting to the docker daemon. Defaults to ClientFromUrl(). env_param (ClientFromEnv, optional): Environment variables parameter required to connect to the docker daemon. Defaults to ClientFromEnv(). registry_login_param ([type], optional): Parameter providing docker registry login details. Defaults to Login(). \"\"\" def __init__ ( self , config_services : ConfigServices , ranked_services : RankedConfigServices , wait_time_between_container_start : float = 20.0 , registry_login_param = Login (), env_param : ClientFromEnv = ClientFromEnv (), url_param : ClientFromUrl = ClientFromUrl (), ) -> None : self . _container_network : ContainerNetwork self . _config_services : ConfigServices = config_services self . _ranked_config_services : RankedConfigServices = ranked_services self . running_containers = RunningContainers () self . _wait_time_between_container_start : float = wait_time_between_container_start self . _registry_login_param : Login = registry_login_param self . initialise_docker_client ( client_env_param = env_param , client_url_param = url_param ) @property def running_containers ( self ) -> RunningContainers : \"\"\"Running container objects Returns: RunningContainer: Running containers \"\"\" return self . _running_containers @running_containers . setter def running_containers ( self , containers : RunningContainers ): self . _running_containers = containers @property def unique_container_label ( self ) -> str : \"\"\"Unique test string label. Returns: str: unique label \"\"\" return self . _unique_container_label @unique_container_label . setter def unique_container_label ( self , label : str ): self . _unique_container_label = label def __enter__ ( self ) -> RunningContainers : return self . run () def __exit__ ( self , exc_type , exc_value , exc_tb ): self . stop_running_containers () if exc_tb and exc_type : logger . info ( \" %s [ %s ]: %s \" , exc_type , exc_value , exc_tb ) def run ( self ) -> RunningContainers : \"\"\"Run all Generic Test Containers Raises: AttributeError: When current container being stated had a record it was already running. TimeoutError: When a predicate could not be found in the log over a specified period of time RuntimeError: When an http endpoint did not return the expected specified status code. Exception: When an Unknown error occured during the process of starting a container. Returns: RunningContainer: running containers \"\"\" self . unique_container_label = uuid4 () . hex network_name = f \" { self . unique_container_label } _network\" self . _container_network = ContainerNetwork ( docker_client = self . docker_client , network_name = network_name ) processed_containers_services : Dict [ str , RunningContainer ] = dict () try : for rank in sorted ( self . _ranked_config_services . ranked_services . keys ()): service : Service = self . _config_services . services [ self . _ranked_config_services . ranked_services [ rank ] ] generic_container : GenericContainer = GenericContainer ( docker_client = self . docker_client ) generic_container . with_service ( service , processed_containers_services , self . _container_network . network_name ) . with_registry ( self . _registry_login_param ) . build () generic_container . test_network = self . _container_network generic_container . start () running_container = RunningContainer ( service_name = service . name , config_environment_variables = generic_container . container_environment_variables , generic_container = generic_container , ) processed_containers_services . update ({ service . name : running_container }) time . sleep ( self . _wait_time_between_container_start ) except Exception as exc : self . stop_running_containers ( RunningContainers ( running_containers = processed_containers_services )) logger . info ( \" %s \" , exc ) raise Exception logger . info ( \"The following containers were started: %s \" , list ( processed_containers_services . keys ())) self . running_containers = RunningContainers ( running_containers = processed_containers_services ) return self . running_containers def stop_running_containers ( self , running_containers : RunningContainers = RunningContainers ()): \"\"\"Stop all running containers\"\"\" try : _running_containers : RunningContainers = ( running_containers if running_containers . running_containers else self . running_containers ) for rank in sorted ( self . _ranked_config_services . ranked_services . keys (), reverse = True ): service_name : str = self . _ranked_config_services . ranked_services [ rank ] container : GenericContainer = _running_containers . running_containers [ service_name ] . generic_container # [service_name].generic_container container . stop () if not self . _container_network : self . _container_network = container . test_network logger . info ( \"Successfully stopped container: %s ( %s ): %s \" , service_name , str ( rank ), container . get_container_id (), ) time . sleep ( 5 ) finally : if not self . _container_network : raise AttributeError ( \"Test network could not be removed. Still dangling ...\" ) self . _container_network . remove_network () logger . info ( \"Run the ryuk container here!!!\" ) running_containers : RunningContainers property writable Running container objects Returns: Type Description RunningContainer Running containers unique_container_label : str property writable Unique test string label. Returns: Type Description str unique label run ( self ) -> RunningContainers Run all Generic Test Containers Exceptions: Type Description AttributeError When current container being stated had a record it was already running. TimeoutError When a predicate could not be found in the log over a specified period of time RuntimeError When an http endpoint did not return the expected specified status code. Exception When an Unknown error occured during the process of starting a container. Returns: Type Description RunningContainer running containers Source code in testcompose/run_containers.py def run ( self ) -> RunningContainers : \"\"\"Run all Generic Test Containers Raises: AttributeError: When current container being stated had a record it was already running. TimeoutError: When a predicate could not be found in the log over a specified period of time RuntimeError: When an http endpoint did not return the expected specified status code. Exception: When an Unknown error occured during the process of starting a container. Returns: RunningContainer: running containers \"\"\" self . unique_container_label = uuid4 () . hex network_name = f \" { self . unique_container_label } _network\" self . _container_network = ContainerNetwork ( docker_client = self . docker_client , network_name = network_name ) processed_containers_services : Dict [ str , RunningContainer ] = dict () try : for rank in sorted ( self . _ranked_config_services . ranked_services . keys ()): service : Service = self . _config_services . services [ self . _ranked_config_services . ranked_services [ rank ] ] generic_container : GenericContainer = GenericContainer ( docker_client = self . docker_client ) generic_container . with_service ( service , processed_containers_services , self . _container_network . network_name ) . with_registry ( self . _registry_login_param ) . build () generic_container . test_network = self . _container_network generic_container . start () running_container = RunningContainer ( service_name = service . name , config_environment_variables = generic_container . container_environment_variables , generic_container = generic_container , ) processed_containers_services . update ({ service . name : running_container }) time . sleep ( self . _wait_time_between_container_start ) except Exception as exc : self . stop_running_containers ( RunningContainers ( running_containers = processed_containers_services )) logger . info ( \" %s \" , exc ) raise Exception logger . info ( \"The following containers were started: %s \" , list ( processed_containers_services . keys ())) self . running_containers = RunningContainers ( running_containers = processed_containers_services ) return self . running_containers stop_running_containers ( self , running_containers : RunningContainers = RunningContainers ( running_containers = {})) Stop all running containers Source code in testcompose/run_containers.py def stop_running_containers ( self , running_containers : RunningContainers = RunningContainers ()): \"\"\"Stop all running containers\"\"\" try : _running_containers : RunningContainers = ( running_containers if running_containers . running_containers else self . running_containers ) for rank in sorted ( self . _ranked_config_services . ranked_services . keys (), reverse = True ): service_name : str = self . _ranked_config_services . ranked_services [ rank ] container : GenericContainer = _running_containers . running_containers [ service_name ] . generic_container # [service_name].generic_container container . stop () if not self . _container_network : self . _container_network = container . test_network logger . info ( \"Successfully stopped container: %s ( %s ): %s \" , service_name , str ( rank ), container . get_container_id (), ) time . sleep ( 5 ) finally : if not self . _container_network : raise AttributeError ( \"Test network could not be removed. Still dangling ...\" ) self . _container_network . remove_network () logger . info ( \"Run the ryuk container here!!!\" )","title":"Developer Reference"},{"location":"api/#developer-reference","text":"","title":"Developer Reference"},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient","text":"Source code in testcompose/client/base_docker_client.py class BaseDockerClient ( ABC ): max_timeout = DEFAULT_TIMEOUT_SECONDS max_pool_size = DEFAULT_MAX_POOL_SIZE @property def docker_client ( self ) -> DockerClient : \"\"\"Docker Client Returns: DockerClient: docker client object \"\"\" return self . _docker_client @docker_client . setter def docker_client ( self , client : DockerClient ) -> None : self . _docker_client = client def initialise_docker_client ( self , client_env_param : ClientFromEnv = ClientFromEnv (), client_url_param : ClientFromUrl = ClientFromUrl (), ) -> None : if client_url_param . docker_host : self . docker_client = self . _docker_client_from_url ( client_url_param ) else : self . docker_client = self . _docker_client_from_env ( client_env_param ) self . docker_client . ping () def _docker_client_from_env ( self , client_env_param : ClientFromEnv ) -> DockerClient : return docker . from_env ( version = client_env_param . version , timeout = client_env_param . timeout or BaseDockerClient . max_timeout , max_pool_size = client_env_param . max_pool_size or BaseDockerClient . max_pool_size , use_ssh_client = client_env_param . use_ssh_client , ssl_version = client_env_param . ssl_version , assert_hostname = client_env_param . assert_hostname , environment = client_env_param . environment , ) def _docker_client_from_url ( self , client_url_param : ClientFromUrl ) -> DockerClient : return DockerClient ( base_url = client_url_param . docker_host , version = client_url_param . version , timeout = client_url_param . timeout , tls = client_url_param . tls , user_agent = client_url_param . user_agent , credstor_env = client_url_param . credstor_env , use_ssh_client = client_url_param . use_ssh_client , max_pool_size = client_url_param . max_pool_size , )","title":"BaseDockerClient"},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient.docker_client","text":"Docker Client Returns: Type Description DockerClient docker client object","title":"docker_client"},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient.max_pool_size","text":"","title":"max_pool_size"},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient.max_timeout","text":"","title":"max_timeout"},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient.initialise_docker_client","text":"Source code in testcompose/client/base_docker_client.py def initialise_docker_client ( self , client_env_param : ClientFromEnv = ClientFromEnv (), client_url_param : ClientFromUrl = ClientFromUrl (), ) -> None : if client_url_param . docker_host : self . docker_client = self . _docker_client_from_url ( client_url_param ) else : self . docker_client = self . _docker_client_from_env ( client_env_param ) self . docker_client . ping ()","title":"initialise_docker_client()"},{"location":"api/#testcompose.configs.parse_config.TestConfigParser","text":"Source code in testcompose/configs/parse_config.py class TestConfigParser : @classmethod def parse_config ( cls , file_name : str ) -> ConfigServices : \"\"\"parses and verifies test yaml config file Args: file_name (str): absolutel path of the config file Raises: FileNotFoundError: when config file not present AttributeError: when config file is empty Returns: ConfigServices: A ConfigServices object with all named services in the config \"\"\" if not os . path . exists ( file_name ): raise FileNotFoundError ( f \"Config file { file_name } does not exist!!\" ) contents : Dict [ str , Any ] = dict () with open ( file_name , 'r' ) as fh : contents = yaml . safe_load ( fh ) if not contents : raise AttributeError ( f \"Config content can not be empty\" ) services : Dict [ str , Service ] = dict () for service in contents [ \"services\" ]: services . update ({ service [ \"name\" ]: Service ( ** service )}) test_services : ConfigServices = ConfigServices ( services = services ) return test_services","title":"TestConfigParser"},{"location":"api/#testcompose.configs.parse_config.TestConfigParser.parse_config","text":"parses and verifies test yaml config file Parameters: Name Type Description Default file_name str absolutel path of the config file required Exceptions: Type Description FileNotFoundError when config file not present AttributeError when config file is empty Returns: Type Description ConfigServices A ConfigServices object with all named services in the config Source code in testcompose/configs/parse_config.py @classmethod def parse_config ( cls , file_name : str ) -> ConfigServices : \"\"\"parses and verifies test yaml config file Args: file_name (str): absolutel path of the config file Raises: FileNotFoundError: when config file not present AttributeError: when config file is empty Returns: ConfigServices: A ConfigServices object with all named services in the config \"\"\" if not os . path . exists ( file_name ): raise FileNotFoundError ( f \"Config file { file_name } does not exist!!\" ) contents : Dict [ str , Any ] = dict () with open ( file_name , 'r' ) as fh : contents = yaml . safe_load ( fh ) if not contents : raise AttributeError ( f \"Config content can not be empty\" ) services : Dict [ str , Service ] = dict () for service in contents [ \"services\" ]: services . update ({ service [ \"name\" ]: Service ( ** service )}) test_services : ConfigServices = ConfigServices ( services = services ) return test_services","title":"parse_config()"},{"location":"api/#testcompose.configs.service_config.Config","text":"This class consumes the model created from a config file. This is an important class that sets the precedence of how the different containers are to be started and stopped. Usually, the precedence are set correctly if the depends_on parameter of the config is set. Cyclic dependency will fail the test before it starts. Parameters: Name Type Description Default test_services ConfigServices model resulting from a parsed configuration file. required Source code in testcompose/configs/service_config.py class Config : \"\"\"This class consumes the model created from a config file. This is an important class that sets the precedence of how the different containers are to be started and stopped. Usually, the precedence are set correctly if the `depends_on` parameter of the config is set. Cyclic dependency will fail the test before it starts. Args: test_services (ConfigServices): model resulting from a parsed configuration file. \"\"\" def __init__ ( self , test_services : ConfigServices ) -> None : self . _rank_test_services ( test_services ) @property def ranked_config_services ( self ) -> RankedConfigServices : \"\"\"Object containing the ordered services from the config Returns: RankedServices: ranked container services \"\"\" return self . _ranked_it_services @ranked_config_services . setter def ranked_config_services ( self , ranked_services : RankedConfigServices ) -> None : self . _ranked_it_services = ranked_services def _rank_test_services ( self , test_services : ConfigServices ) -> None : \"\"\" Args: test_services (ConfigServices): model resulting from a parsed configuration file. Raises: ValueError: raised if test_services is `null` AttributeError: raised if no concreate networking is provided \"\"\" if not test_services : logger . error ( \"Config content can not be Null\" ) raise ValueError if not test_services . services : logger . error ( \"No service was found in the provided config\" ) raise ValueError _processed_containers : Dict [ str , int ] = self . _compute_container_ranks ( ranked_services = dict (), config_services = test_services , ) _processed_containers_reversed : Dict [ int , str ] = { rank : service for service , rank in _processed_containers . items () } self . ranked_config_services = RankedConfigServices ( ranked_services = _processed_containers_reversed ) def _compute_container_ranks ( self , * , ranked_services : Dict [ str , int ], config_services : ConfigServices , ) -> Dict [ str , int ]: \"\"\"The main method that computes the ranking of the services specified in the config. Args: ranked_services (Dict[str, int]): dict container service name and their assigned ranks config_services (ConfigServices): config services generated from the supplied configuration file Raises: AttributeError: raised to prevent empty configuration properties to be passed to this function ValueError: rasied when cyclic dependency is detected Returns: Dict[str, int]: A list of ranked service models. \"\"\" _ranked_services : Dict [ str , int ] = deepcopy ( ranked_services ) if not config_services : raise AttributeError ( \"A valid config for test services must be provided\" ) rank = len ( ranked_services . keys ()) if len ( config_services . services . keys ()) == len ( ranked_services . keys ()): return ranked_services else : services : Dict [ str , Service ] = { x : y for x , y in config_services . services . items () if x not in _ranked_services } for service_name , service in services . items (): if not service . depends_on : _ranked_services . update ({ service_name : rank }) rank += 1 else : if set ( service . depends_on ) . issubset ( _ranked_services . keys () ) and not self . _check_cyclic_dependency ( [ config_services . services [ x ] for x in _ranked_services ], service_name ): _ranked_services . update ({ service_name : rank }) rank += 1 elif not set ( service . depends_on ) . issubset ( list ( config_services . services . keys ())): raise AttributeError ( f \"Invalid service name or dependencies detected: { service_name } <=> { set ( service . depends_on ) } \" ) return self . _compute_container_ranks ( ranked_services = _ranked_services , config_services = config_services ) @staticmethod def _check_cyclic_dependency ( processed_services : List [ Service ], dependent_service_name : str ) -> boolean : for service in processed_services : if set ([ dependent_service_name ]) . issubset ( service . depends_on ): return True return False","title":"Config"},{"location":"api/#testcompose.configs.service_config.Config.ranked_config_services","text":"Object containing the ordered services from the config Returns: Type Description RankedServices ranked container services","title":"ranked_config_services"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer","text":"Container Builder Source code in testcompose/containers/base_service_container.py class BaseServiceContainer ( ABC ): \"\"\"Container Builder\"\"\" def __init__ ( self , docker_client : DockerClient ) -> None : self . _image : str self . _command : str self . _entry_point : str self . _host_name : str self . _network : str self . _http_waiter : HttpWaitParameter self . _log_waiter : LogWaitParameter self . _registry = Login () self . _environments : Dict [ str , Any ] = dict () self . _ports : Dict [ int , Any ] = dict () self . _volumes : Dict [ str , Dict [ str , str ]] = dict () self . _docker_host : Optional [ str ] = None self . _image_pull_policy = 'ALWAYS_PULL' self . docker_client = docker_client @property def container_environment_variables ( self ) -> Dict [ str , Any ]: return self . _container_environment_variables @container_environment_variables . setter def container_environment_variables ( self , env : Dict [ str , Any ]) -> None : self . _container_environment_variables = deepcopy ( env ) @property def docker_client ( self ) -> DockerClient : \"\"\"Docker Client Returns: DockerClient: client object \"\"\" return self . _docker_client @docker_client . setter def docker_client ( self , client : DockerClient ): self . _docker_client = client def with_service ( self , service : Service , processed_containers_services : Dict [ str , RunningContainer ], network : str ) -> 'BaseServiceContainer' : \"\"\" The initialization method that converts a config service into a Generic Container. It leverages other internal _with methods to assign the complete container properties. Args: service (Service): a config service processed_containers_services (Dict[str, Any]): a dict of a service that had already been initiated and the container is running. network (str): the test network name, to attach all containers to. Returns: BaseServiceContainer \"\"\" self . _with_image ( service . image ) self . _with_command ( service . command ) # type: ignore ( substituted_env_variables , modified_exposed_ports , ) = ContainerUtils . replace_container_config_placeholders ( service_env_variables = service . environment , running_containers = processed_containers_services , service_name = service . name , exposed_ports = service . exposed_ports , ) self . _with_environment ( substituted_env_variables ) self . _with_exposed_ports ( modified_exposed_ports ) self . _with_wait_for_http ( service . http_wait_parameters ) # type: ignore self . _with_volumes ( service . volumes ) self . _with_entry_point ( service . entrypoint ) # type: ignore self . _with_log_waiter ( service . log_wait_parameters ) # type: ignore self . _with_host_name ( service . name ) self . _with_network ( network ) return self def _with_network ( self , network : str ): self . _network = network def _with_log_waiter ( self , waiter : LogWaitParameter ) -> None : self . _log_waiter = waiter def _with_host_name ( self , host : str ) -> None : self . _host_name = host def _with_exposed_ports ( self , ports : Optional [ List [ str ]]) -> None : \"\"\"List of exposed port to be assigned random port numbers on the host. Random ports are exposed to the host. A fixed port can be assigned on the host by providing the port in the format **[host_port:container_port]** Args: ports (Optional[List[str]]): list of container exposed ports \"\"\" if ports : for port in ports : _ports = str ( port ) . split ( \":\" ) if len ( _ports ) == 2 : self . _ports [ int ( _ports [ 1 ])] = int ( _ports [ 0 ]) else : self . _ports [ int ( port )] = None def _with_wait_for_http ( self , wait_parameter : HttpWaitParameter ) -> None : self . _http_waiter = wait_parameter def _with_volumes ( self , volumes : Optional [ List [ VolumeMapping ]]) -> None : \"\"\"A list of volume mappings to be mounted in the container. VolumeMapping: host: host volume path or a docker volume name container: path to mount the host volume in the container mode: volume mode [ro|rw] source: source of the volume [filesystem|dockervolume] filesystem: a file or directory to be mounted dockervolume: a docker volume (existing or to be created) Args: volumes (Optional[List[VolumeMapping]]): Optional list of volumes to mount on the container \"\"\" if volumes : for vol in volumes : host_bind : Optional [ str ] = None if vol . source == VolumeSourceTypes . DOCKER_VOLUME_SOURCE : host_bind = vol . host elif vol . source == VolumeSourceTypes . FILESYSTEM_SOURCE : host_bind = str ( pathlib . Path ( vol . host ) . absolute ()) if not host_bind : raise ValueError ( \"Volume source can only be one of local|docker\" ) self . _volumes [ host_bind ] = { \"bind\" : vol . container , \"mode\" : vol . mode } def _with_environment ( self , env : Optional [ Dict [ str , Any ]]) -> None : \"\"\"Environment variables for running containers Args: env (Optional[Dict[str, Any]]): [description] \"\"\" self . container_environment_variables = env or dict () if env : self . _environments = deepcopy ( env ) def _with_image ( self , image : str , image_pull_policy = \"ALWAYS_PULL\" ) -> None : # TODO: Allow pull toggle self . _image = image self . _image_pull_policy = 'ALWAYS_PULL' def _with_command ( self , command : str ) -> None : self . _command = command def with_registry ( self , registry : Login ) -> 'BaseServiceContainer' : self . _registry = registry return self def _with_entry_point ( self , entry_point : str ) -> None : self . _entry_point = entry_point def build ( self ) -> 'BaseServiceContainer' : \"\"\"Construct a Generic container from a config service Args: docker_client (DockerClient): docker client \"\"\" if self . _registry : self . docker_client . login ( ** self . _registry . dict ()) print ( f \"Pulling image { self . _image } \" ) if not self . _image : raise ValueError ( \"A valid Image entity must be provided\" ) try : self . docker_client . images . get ( name = self . _image ) except ImageNotFound : self . docker_client . images . pull ( repository = self . _image ) except Exception : print ( traceback . format_exc ()) return self @abstractmethod def start ( self ) -> None : raise NotImplementedError @abstractmethod def stop ( self , force = True , delete_volume = True ) -> None : raise NotImplementedError","title":"BaseServiceContainer"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer.container_environment_variables","text":"","title":"container_environment_variables"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer.docker_client","text":"Docker Client Returns: Type Description DockerClient client object","title":"docker_client"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer.build","text":"Construct a Generic container from a config service Parameters: Name Type Description Default docker_client DockerClient docker client required Source code in testcompose/containers/base_service_container.py def build ( self ) -> 'BaseServiceContainer' : \"\"\"Construct a Generic container from a config service Args: docker_client (DockerClient): docker client \"\"\" if self . _registry : self . docker_client . login ( ** self . _registry . dict ()) print ( f \"Pulling image { self . _image } \" ) if not self . _image : raise ValueError ( \"A valid Image entity must be provided\" ) try : self . docker_client . images . get ( name = self . _image ) except ImageNotFound : self . docker_client . images . pull ( repository = self . _image ) except Exception : print ( traceback . format_exc ()) return self","title":"build()"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer.start","text":"Source code in testcompose/containers/base_service_container.py @abstractmethod def start ( self ) -> None : raise NotImplementedError","title":"start()"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer.stop","text":"Source code in testcompose/containers/base_service_container.py @abstractmethod def stop ( self , force = True , delete_volume = True ) -> None : raise NotImplementedError","title":"stop()"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer.with_registry","text":"Source code in testcompose/containers/base_service_container.py def with_registry ( self , registry : Login ) -> 'BaseServiceContainer' : self . _registry = registry return self","title":"with_registry()"},{"location":"api/#testcompose.containers.base_service_container.BaseServiceContainer.with_service","text":"The initialization method that converts a config service into a Generic Container. It leverages other internal _with methods to assign the complete container properties. Parameters: Name Type Description Default service Service a config service required processed_containers_services Dict[str, Any] a dict of a service that had already been initiated and the container is running. required network str the test network name, to attach all containers to. required Returns: Type Description BaseServiceContainer BaseServiceContainer Source code in testcompose/containers/base_service_container.py def with_service ( self , service : Service , processed_containers_services : Dict [ str , RunningContainer ], network : str ) -> 'BaseServiceContainer' : \"\"\" The initialization method that converts a config service into a Generic Container. It leverages other internal _with methods to assign the complete container properties. Args: service (Service): a config service processed_containers_services (Dict[str, Any]): a dict of a service that had already been initiated and the container is running. network (str): the test network name, to attach all containers to. Returns: BaseServiceContainer \"\"\" self . _with_image ( service . image ) self . _with_command ( service . command ) # type: ignore ( substituted_env_variables , modified_exposed_ports , ) = ContainerUtils . replace_container_config_placeholders ( service_env_variables = service . environment , running_containers = processed_containers_services , service_name = service . name , exposed_ports = service . exposed_ports , ) self . _with_environment ( substituted_env_variables ) self . _with_exposed_ports ( modified_exposed_ports ) self . _with_wait_for_http ( service . http_wait_parameters ) # type: ignore self . _with_volumes ( service . volumes ) self . _with_entry_point ( service . entrypoint ) # type: ignore self . _with_log_waiter ( service . log_wait_parameters ) # type: ignore self . _with_host_name ( service . name ) self . _with_network ( network ) return self","title":"with_service()"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork","text":"Network management for running container.This class ensures all containers in the same test belong to the same network. Contians utility to create and cleanup network. Parameters: Name Type Description Default docker_client DockerClient Docker client required network_name str Name of test network required Source code in testcompose/containers/container_network.py class ContainerNetwork : \"\"\"Network management for running container.This class ensures all containers in the same test belong to the same network. Contians utility to create and cleanup network. Args: docker_client (DockerClient): Docker client network_name (str): Name of test network \"\"\" def __init__ ( self , docker_client : DockerClient , network_name : str ) -> None : self . _docker_client = docker_client self . _get_defined_network ( network_name ) @property def container_network ( self ) -> Network : \"\"\"Network Object Returns: docker.models.networks.Network: container network object \"\"\" return self . _container_network @container_network . setter def container_network ( self , network : Network ) -> None : self . _container_network = network @property def network_name ( self ) -> str : \"\"\"Network Name Returns: str: Network Name \"\"\" return self . container_network . name def _get_defined_network ( self , network_name : str ): \"\"\"Identify or create container network Args: network_name (str): Network name Raises: AttributeError: When network does not exist or can not be created. \"\"\" self . container_network = self . _create_group_network ( network_name ) @property def container_network_id ( self ) -> Optional [ str ]: \"\"\"Container Short Id Returns: Optional[str]: container_id \"\"\" return self . container_network . short_id def remove_network ( self ): \"\"\"Cleanup created network\"\"\" if self . container_network . name not in [ 'bridge' , 'none' , 'host' ]: self . container_network . remove () def _create_group_network ( self , network_name : str , label : Dict [ str , str ] = dict (), driver : str = DefaultNeworkDrivers . DEFAULT_BRIDGE_NETWORK , ) -> Network : existing_networks : List [ Network ] = list () try : existing_networks = self . _docker_client . networks . list ( names = [ network_name ]) except Exception : pass if not existing_networks : return self . _docker_client . networks . create ( name = network_name , driver = driver , check_duplicate = True , internal = False , labels = label or None , enable_ipv6 = False , attachable = True , scope = 'local' , ) else : return existing_networks [ 0 ]","title":"ContainerNetwork"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.container_network","text":"Network Object Returns: Type Description docker.models.networks.Network container network object","title":"container_network"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.container_network_id","text":"Container Short Id Returns: Type Description Optional[str] container_id","title":"container_network_id"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.network_name","text":"Network Name Returns: Type Description str Network Name","title":"network_name"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.remove_network","text":"Cleanup created network Source code in testcompose/containers/container_network.py def remove_network ( self ): \"\"\"Cleanup created network\"\"\" if self . container_network . name not in [ 'bridge' , 'none' , 'host' ]: self . container_network . remove ()","title":"remove_network()"},{"location":"api/#testcompose.containers.container_utils.ContainerUtils","text":"Source code in testcompose/containers/container_utils.py class ContainerUtils : @staticmethod def replace_container_config_placeholders ( service_env_variables : Dict [ str , Any ], running_containers : Dict [ str , RunningContainer ], service_name : str , exposed_ports : List [ str ], ) -> Tuple [ Dict [ str , Any ], List [ str ]]: \"\"\"Utility method to replace placeholders in the service containers. Placeholders are usually of the form *${container_name.containerenv_variable}*. Args: service_env_variables (Dict[str, Any]): Dict of config environment variables running_containers Dict[str, RunningContainer]: Running container object service_name (str): service name as specified in the config exposed_ports (List[str]): container exposed ports Raises: ValueError: when a placeholder variable is not of the form service_name.variable_name AttributeError: When a service name could not be found in the list of services obtained from the provided config file. Returns: Tuple[Dict[str, Any], List[str]]: A tuple of `env_config` and `exposed_ports` \"\"\" pattern = \" \\\\ $ \\\\ {([^}]*)}\" substituted_env_variables : Dict [ str , Any ] = copy ( service_env_variables ) modified_exposed_ports = deepcopy ( exposed_ports ) cmpl = re . compile ( pattern = pattern ) . findall for k , v in service_env_variables . items (): if isinstance ( v , str ): replaced_variable = v for occurence in cmpl ( v ): if len ( str ( occurence ) . split ( \".\" )) != 2 : raise ValueError container_name , variable_name = str ( occurence ) . split ( \".\" ) value = None value , _exposed_ports = ContainerUtils . _external_ports_variables ( running_containers , service_name , container_name , variable_name , modified_exposed_ports , ) if _exposed_ports : modified_exposed_ports = deepcopy ( _exposed_ports ) replaced_variable = replaced_variable . replace ( f \"$ {{ { occurence } }} \" , str ( value )) substituted_env_variables [ k ] = replaced_variable return substituted_env_variables , modified_exposed_ports @staticmethod def _get_free_host_port () -> str : \"\"\"Get a free random port number from the container host Returns: str: port number \"\"\" s = socket . socket ( family = socket . AF_INET , type = socket . SOCK_STREAM ) s . setsockopt ( socket . SOL_SOCKET , socket . SO_REUSEPORT , 1 ) s . settimeout ( 2 ) s . bind (( \"\" , 0 )) _ , port = s . getsockname () s . close () return port @staticmethod def _external_ports_variables ( running_containers : Dict [ str , RunningContainer ], service_name : str , container_name : str , variable_name : str , exposed_ports : List [ str ] = list (), ): value = None _exposed_ports = list () if container_name . lower () == SupportedPlaceholders . SELF_HOST or variable_name . lower () in [ SupportedPlaceholders . CONTAINER_HOSTNAME , SupportedPlaceholders . EXTERNAL_PORT , SupportedPlaceholders . CONTAINER_HOST_ADDRESS , ]: if ( container_name . lower () == SupportedPlaceholders . SELF_HOST and variable_name . lower () == SupportedPlaceholders . CONTAINER_HOSTNAME ): value = service_name elif ( container_name . lower () != SupportedPlaceholders . SELF_HOST and variable_name . lower () == SupportedPlaceholders . CONTAINER_HOSTNAME ): value = container_name else : if variable_name . lower () . startswith ( SupportedPlaceholders . EXTERNAL_PORT ): value , _exposed_ports = ContainerUtils . _external_port_variables ( variable_name , exposed_ports ) elif variable_name . lower () == SupportedPlaceholders . CONTAINER_HOST_ADDRESS : value = socket . gethostbyname ( socket . gethostname ()) else : value = running_containers [ f \" { container_name . lower () } \" ] . generic_container . container_environment_variables [ f \" { variable_name . upper () } \" ] return value , _exposed_ports @staticmethod def _external_port_variables ( variable_name : str , exposed_ports : List [ str ]): _exposed_ports = deepcopy ( exposed_ports ) container_port = re . sub ( SupportedPlaceholders . EXTERNAL_PORT + \"_\" , \"\" , variable_name ) host_port = ContainerUtils . _get_free_host_port () if container_port and container_port not in exposed_ports : raise AttributeError ( f \"self.hostport_ { container_port } must be a valid supplied exposed_ports value!\" ) _exposed_ports . remove ( container_port ) _exposed_ports . append ( f \" { host_port } : { container_port } \" ) value = str ( host_port ) return value , _exposed_ports","title":"ContainerUtils"},{"location":"api/#testcompose.containers.container_utils.ContainerUtils.replace_container_config_placeholders","text":"Utility method to replace placeholders in the service containers. Placeholders are usually of the form ${container_name.containerenv_variable} . Parameters: Name Type Description Default service_env_variables Dict[str, Any] Dict of config environment variables required running_containers Dict[str, RunningContainer] Running container object required service_name str service name as specified in the config required exposed_ports List[str] container exposed ports required Exceptions: Type Description ValueError when a placeholder variable is not of the form service_name.variable_name AttributeError When a service name could not be found in the list of services obtained from the provided config file. Returns: Type Description Tuple[Dict[str, Any], List[str]] A tuple of env_config and exposed_ports Source code in testcompose/containers/container_utils.py @staticmethod def replace_container_config_placeholders ( service_env_variables : Dict [ str , Any ], running_containers : Dict [ str , RunningContainer ], service_name : str , exposed_ports : List [ str ], ) -> Tuple [ Dict [ str , Any ], List [ str ]]: \"\"\"Utility method to replace placeholders in the service containers. Placeholders are usually of the form *${container_name.containerenv_variable}*. Args: service_env_variables (Dict[str, Any]): Dict of config environment variables running_containers Dict[str, RunningContainer]: Running container object service_name (str): service name as specified in the config exposed_ports (List[str]): container exposed ports Raises: ValueError: when a placeholder variable is not of the form service_name.variable_name AttributeError: When a service name could not be found in the list of services obtained from the provided config file. Returns: Tuple[Dict[str, Any], List[str]]: A tuple of `env_config` and `exposed_ports` \"\"\" pattern = \" \\\\ $ \\\\ {([^}]*)}\" substituted_env_variables : Dict [ str , Any ] = copy ( service_env_variables ) modified_exposed_ports = deepcopy ( exposed_ports ) cmpl = re . compile ( pattern = pattern ) . findall for k , v in service_env_variables . items (): if isinstance ( v , str ): replaced_variable = v for occurence in cmpl ( v ): if len ( str ( occurence ) . split ( \".\" )) != 2 : raise ValueError container_name , variable_name = str ( occurence ) . split ( \".\" ) value = None value , _exposed_ports = ContainerUtils . _external_ports_variables ( running_containers , service_name , container_name , variable_name , modified_exposed_ports , ) if _exposed_ports : modified_exposed_ports = deepcopy ( _exposed_ports ) replaced_variable = replaced_variable . replace ( f \"$ {{ { occurence } }} \" , str ( value )) substituted_env_variables [ k ] = replaced_variable return substituted_env_variables , modified_exposed_ports","title":"replace_container_config_placeholders()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer","text":"Generic container object to control the base properties of running containers. This class manipulates the base components of a container. Extra parameters can be provided as keyword arguments. Parameters: Name Type Description Default docker_client DockerClient docker client required Source code in testcompose/containers/generic_container.py class GenericContainer ( BaseServiceContainer ): \"\"\"Generic container object to control the base properties of running containers. This class manipulates the base components of a container. Extra parameters can be provided as keyword arguments. Args: docker_client (DockerClient): docker client \"\"\" def __init__ ( self , docker_client : DockerClient , ** kwargs ) -> None : super () . __init__ ( docker_client ) self . _kwargs = kwargs @property def test_network ( self ) -> ContainerNetwork : return self . _container_network @test_network . setter def test_network ( self , network : ContainerNetwork ) -> None : self . _container_network = network @property def test_container ( self ) -> Container : return self . _container @test_container . setter def test_container ( self , container : Container ) -> None : self . _container = container @property def test_container_attr ( self ) -> RunningContainerAttributes : \"\"\"Running container attributes Returns: RunningContainerAttributes: Container attribute object \"\"\" return self . _container_attr @test_container_attr . setter def test_container_attr ( self , atrr : RunningContainerAttributes ): \"\"\"Running container attributes. Execute reload() to refresh this property. Args: atrr (RunningContainerAttributes): container attributes \"\"\" self . _container_attr = atrr def start ( self ) -> None : \"\"\"Start a container\"\"\" if not self . docker_client . ping (): raise RuntimeError ( \"Docker Client not Running. Please check your docker settings and try again\" ) try : self . test_container = self . docker_client . containers . run ( image = self . _image , command = self . _command , detach = True , environment = self . _environments , ports = self . _ports , volumes = self . _volumes , entrypoint = self . _entry_point , auto_remove = True , remove = True , network = self . _network , hostname = self . _host_name , ** self . _kwargs , ) WaitingUtils . container_status ( self . test_container ) self . reload () LogWaiter . search_container_logs ( self . test_container , self . _log_waiter ) if self . _http_waiter : mapped_http_port : Dict [ str , str ] = dict () mapped_http_port [ str ( self . _http_waiter . http_port )] = self . get_exposed_port ( str ( self . _http_waiter . http_port ) ) EndpointWaiters . wait_for_http ( self . _http_waiter , mapped_http_port ) except Exception as exc : print ( exc ) self . stop () def stop ( self , force = True , delete_volume = True ) -> None : \"\"\"Stop a running container Args: force (bool, optional): [description]. Defaults to True. delete_volume (bool, optional): [description]. Defaults to True. \"\"\" try : if self . test_container : self . test_container . remove ( v = delete_volume , force = force ) except APIError as exc : print ( exc ) def reload ( self ) -> None : \"\"\"Reload the attributes of a running container\"\"\" self . test_container . reload () self . test_container_attr = RunningContainerAttributes ( ** self . test_container . attrs ) if not WaitingUtils . container_status ( self . test_container ): raise RuntimeError ( \"Container could not be started\" ) def get_exposed_port ( self , port : str ) -> str : \"\"\"Get host port bound to the container exposed port Args: port (str): container exposed port Returns: str: Host port bound to the container exposed port \"\"\" if not port : return None # type: ignore return self . _get_mapped_container_ports ([ port ])[ port ] def _get_mapped_container_ports ( self , exposed_ports : List [ str ]) -> Dict [ str , str ]: \"\"\"Host port bound to the container returned as a k/v of the container exposed port as key and the host bound port as the value. Args: ports (List[str]): List of container exposed port to be mapped to host port Returns: Dict[str, str]: Mapped container-host ports. \"\"\" mapped_ports : Dict [ str , str ] = dict () ports : Dict [ str , Any ] = self . test_container_attr . NetworkSettings . Ports # for port in ports : container_port = re . sub ( f \"[^0-9]\" , \"\" , port ) if container_port in exposed_ports and ports [ port ] and isinstance ( ports [ port ], list ): print ( ports , ports [ port ]) host_ports : ContainerMappedPorts = ContainerMappedPorts ( ** ( ports [ port ][ 0 ])) print ( host_ports ) mapped_ports . update ({ container_port : host_ports . HostPort }) return mapped_ports def get_container_id ( self ) -> Optional [ str ]: \"\"\"Container id Returns: Optional[str]: Container Id \"\"\" if self . test_container : return self . test_container . id return None def get_container_host_ip ( self ) -> str : \"\"\"Container Host IP address Returns: str: container host IP Address \"\"\" return socket . gethostbyname ( socket . gethostname ()) def exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ]: \"\"\"Execute a command inside a container once it started running. Args: command (Union[str, List[str]]): command to run in the container Raises: RuntimeError: when the container object is not set Returns: Tuple[int, ByteString]: A tuple of (exit_code, output) \"\"\" if not self . test_container : raise RuntimeError ( \"Container must already be running to exec a command\" ) return self . test_container . exec_run ( cmd = command )","title":"GenericContainer"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.test_container","text":"","title":"test_container"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.test_container_attr","text":"Running container attributes Returns: Type Description RunningContainerAttributes Container attribute object","title":"test_container_attr"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.test_network","text":"","title":"test_network"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.exe_command","text":"Execute a command inside a container once it started running. Parameters: Name Type Description Default command Union[str, List[str]] command to run in the container required Exceptions: Type Description RuntimeError when the container object is not set Returns: Type Description Tuple[int, ByteString] A tuple of (exit_code, output) Source code in testcompose/containers/generic_container.py def exe_command ( self , command : Union [ str , List [ str ]]) -> Tuple [ int , ByteString ]: \"\"\"Execute a command inside a container once it started running. Args: command (Union[str, List[str]]): command to run in the container Raises: RuntimeError: when the container object is not set Returns: Tuple[int, ByteString]: A tuple of (exit_code, output) \"\"\" if not self . test_container : raise RuntimeError ( \"Container must already be running to exec a command\" ) return self . test_container . exec_run ( cmd = command )","title":"exe_command()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_host_ip","text":"Container Host IP address Returns: Type Description str container host IP Address Source code in testcompose/containers/generic_container.py def get_container_host_ip ( self ) -> str : \"\"\"Container Host IP address Returns: str: container host IP Address \"\"\" return socket . gethostbyname ( socket . gethostname ())","title":"get_container_host_ip()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_id","text":"Container id Returns: Type Description Optional[str] Container Id Source code in testcompose/containers/generic_container.py def get_container_id ( self ) -> Optional [ str ]: \"\"\"Container id Returns: Optional[str]: Container Id \"\"\" if self . test_container : return self . test_container . id return None","title":"get_container_id()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_exposed_port","text":"Get host port bound to the container exposed port Parameters: Name Type Description Default port str container exposed port required Returns: Type Description str Host port bound to the container exposed port Source code in testcompose/containers/generic_container.py def get_exposed_port ( self , port : str ) -> str : \"\"\"Get host port bound to the container exposed port Args: port (str): container exposed port Returns: str: Host port bound to the container exposed port \"\"\" if not port : return None # type: ignore return self . _get_mapped_container_ports ([ port ])[ port ]","title":"get_exposed_port()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.reload","text":"Reload the attributes of a running container Source code in testcompose/containers/generic_container.py def reload ( self ) -> None : \"\"\"Reload the attributes of a running container\"\"\" self . test_container . reload () self . test_container_attr = RunningContainerAttributes ( ** self . test_container . attrs ) if not WaitingUtils . container_status ( self . test_container ): raise RuntimeError ( \"Container could not be started\" )","title":"reload()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.start","text":"Start a container Source code in testcompose/containers/generic_container.py def start ( self ) -> None : \"\"\"Start a container\"\"\" if not self . docker_client . ping (): raise RuntimeError ( \"Docker Client not Running. Please check your docker settings and try again\" ) try : self . test_container = self . docker_client . containers . run ( image = self . _image , command = self . _command , detach = True , environment = self . _environments , ports = self . _ports , volumes = self . _volumes , entrypoint = self . _entry_point , auto_remove = True , remove = True , network = self . _network , hostname = self . _host_name , ** self . _kwargs , ) WaitingUtils . container_status ( self . test_container ) self . reload () LogWaiter . search_container_logs ( self . test_container , self . _log_waiter ) if self . _http_waiter : mapped_http_port : Dict [ str , str ] = dict () mapped_http_port [ str ( self . _http_waiter . http_port )] = self . get_exposed_port ( str ( self . _http_waiter . http_port ) ) EndpointWaiters . wait_for_http ( self . _http_waiter , mapped_http_port ) except Exception as exc : print ( exc ) self . stop ()","title":"start()"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.stop","text":"Stop a running container Parameters: Name Type Description Default force bool [description]. Defaults to True. True delete_volume bool [description]. Defaults to True. True Source code in testcompose/containers/generic_container.py def stop ( self , force = True , delete_volume = True ) -> None : \"\"\"Stop a running container Args: force (bool, optional): [description]. Defaults to True. delete_volume (bool, optional): [description]. Defaults to True. \"\"\" try : if self . test_container : self . test_container . remove ( v = delete_volume , force = force ) except APIError as exc : print ( exc )","title":"stop()"},{"location":"api/#testcompose.containers.supported_placeholders.SupportedPlaceholders","text":"SupportedPlaceholders(SELF_HOST: str = 'self', CONTAINER_HOSTNAME: str = 'container_hostname', EXTERNAL_PORT: str = 'external_port', CONTAINER_HOST_ADDRESS: str = 'container_host_address') Source code in testcompose/containers/supported_placeholders.py @dataclass ( frozen = True ) class SupportedPlaceholders : SELF_HOST : str = 'self' CONTAINER_HOSTNAME : str = 'container_hostname' EXTERNAL_PORT : str = 'external_port' CONTAINER_HOST_ADDRESS : str = 'container_host_address'","title":"SupportedPlaceholders"},{"location":"api/#testcompose.containers.supported_placeholders.SupportedPlaceholders.CONTAINER_HOSTNAME","text":"","title":"CONTAINER_HOSTNAME"},{"location":"api/#testcompose.containers.supported_placeholders.SupportedPlaceholders.CONTAINER_HOST_ADDRESS","text":"","title":"CONTAINER_HOST_ADDRESS"},{"location":"api/#testcompose.containers.supported_placeholders.SupportedPlaceholders.EXTERNAL_PORT","text":"","title":"EXTERNAL_PORT"},{"location":"api/#testcompose.containers.supported_placeholders.SupportedPlaceholders.SELF_HOST","text":"","title":"SELF_HOST"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv","text":"Source code in testcompose/models/client/client_login.py class ClientFromEnv ( BaseModel ): version : str = \"auto\" timeout : Optional [ int ] = None max_pool_size : Optional [ int ] = None use_ssh_client : bool = False ssl_version : Optional [ int ] = None assert_hostname : Optional [ bool ] = None environment : Optional [ Dict [ str , Any ]] = None","title":"ClientFromEnv"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.assert_hostname","text":"","title":"assert_hostname"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.environment","text":"","title":"environment"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.max_pool_size","text":"","title":"max_pool_size"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.ssl_version","text":"","title":"ssl_version"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.timeout","text":"","title":"timeout"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.use_ssh_client","text":"","title":"use_ssh_client"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.version","text":"","title":"version"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl","text":"Source code in testcompose/models/client/client_login.py class ClientFromUrl ( BaseModel ): docker_host : Optional [ str ] = None version : str = \"auto\" timeout : Optional [ int ] = None tls : Optional [ bool ] = None user_agent : Optional [ str ] = None credstor_env : Optional [ Dict [ str , Any ]] = None use_ssh_client : Optional [ bool ] = None max_pool_size : Optional [ int ] = None","title":"ClientFromUrl"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.credstor_env","text":"","title":"credstor_env"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.docker_host","text":"","title":"docker_host"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.max_pool_size","text":"","title":"max_pool_size"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.timeout","text":"","title":"timeout"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.tls","text":"","title":"tls"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.use_ssh_client","text":"","title":"use_ssh_client"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.user_agent","text":"","title":"user_agent"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.version","text":"","title":"version"},{"location":"api/#testcompose.models.client.registry_parameters.Login","text":"Source code in testcompose/models/client/registry_parameters.py class Login ( BaseModel ): username : Optional [ str ] = None password : Optional [ str ] = None email : Optional [ str ] = None registry : Optional [ str ] = None reauth : Optional [ bool ] = False dockercfg_path : Optional [ str ] = None","title":"Login"},{"location":"api/#testcompose.models.client.registry_parameters.Login.dockercfg_path","text":"","title":"dockercfg_path"},{"location":"api/#testcompose.models.client.registry_parameters.Login.email","text":"","title":"email"},{"location":"api/#testcompose.models.client.registry_parameters.Login.password","text":"","title":"password"},{"location":"api/#testcompose.models.client.registry_parameters.Login.reauth","text":"","title":"reauth"},{"location":"api/#testcompose.models.client.registry_parameters.Login.registry","text":"","title":"registry"},{"location":"api/#testcompose.models.client.registry_parameters.Login.username","text":"","title":"username"},{"location":"api/#testcompose.models.config.config_services.Service","text":"Source code in testcompose/models/config/config_services.py class Service ( BaseModel ): name : str image : str exposed_ports : List [ str ] command : Optional [ str ] = None environment : Dict [ str , Any ] = dict () depends_on : List [ str ] = list () volumes : List [ VolumeMapping ] = list () log_wait_parameters : Optional [ LogWaitParameter ] = None http_wait_parameters : Optional [ HttpWaitParameter ] = None https_wait_parameters : Optional [ HttpWaitParameter ] = None entrypoint : Optional [ str ] = None @validator ( 'name' ) def validate_service_name ( cls , v ): if not v : raise AttributeError ( \"Service name is required\" ) return v @validator ( 'image' ) def validate_image ( cls , v ): if not v : raise AttributeError ( \"A valid image name is required\" ) return v","title":"Service"},{"location":"api/#testcompose.models.config.config_services.Service.command","text":"","title":"command"},{"location":"api/#testcompose.models.config.config_services.Service.depends_on","text":"","title":"depends_on"},{"location":"api/#testcompose.models.config.config_services.Service.entrypoint","text":"","title":"entrypoint"},{"location":"api/#testcompose.models.config.config_services.Service.environment","text":"","title":"environment"},{"location":"api/#testcompose.models.config.config_services.Service.exposed_ports","text":"","title":"exposed_ports"},{"location":"api/#testcompose.models.config.config_services.Service.http_wait_parameters","text":"","title":"http_wait_parameters"},{"location":"api/#testcompose.models.config.config_services.Service.https_wait_parameters","text":"","title":"https_wait_parameters"},{"location":"api/#testcompose.models.config.config_services.Service.image","text":"","title":"image"},{"location":"api/#testcompose.models.config.config_services.Service.log_wait_parameters","text":"","title":"log_wait_parameters"},{"location":"api/#testcompose.models.config.config_services.Service.name","text":"","title":"name"},{"location":"api/#testcompose.models.config.config_services.Service.volumes","text":"","title":"volumes"},{"location":"api/#testcompose.models.config.config_services.Service.validate_image","text":"Source code in testcompose/models/config/config_services.py @validator ( 'image' ) def validate_image ( cls , v ): if not v : raise AttributeError ( \"A valid image name is required\" ) return v","title":"validate_image()"},{"location":"api/#testcompose.models.config.config_services.Service.validate_service_name","text":"Source code in testcompose/models/config/config_services.py @validator ( 'name' ) def validate_service_name ( cls , v ): if not v : raise AttributeError ( \"Service name is required\" ) return v","title":"validate_service_name()"},{"location":"api/#testcompose.models.config.config_services.ConfigServices","text":"ConfigServices holds Dict of Service and their names Parameters: Name Type Description Default services Dict[name, Service] required Source code in testcompose/models/config/config_services.py class ConfigServices ( BaseModel ): \"\"\" ConfigServices holds Dict of Service and their names Args: services: Dict[name, Service] \"\"\" services : Dict [ str , Service ]","title":"ConfigServices"},{"location":"api/#testcompose.models.config.config_services.ConfigServices.services","text":"","title":"services"},{"location":"api/#testcompose.models.config.config_services.RankedConfigServices","text":"RankedConfigServices holds a dict of services ranked in the order they are to be started. Parameters: Name Type Description Default ranked_services Dict[rank, name] required Source code in testcompose/models/config/config_services.py class RankedConfigServices ( BaseModel ): \"\"\" RankedConfigServices holds a dict of services ranked in the order they are to be started. Args: ranked_services: Dict[rank, name] \"\"\" ranked_services : Dict [ int , str ] = dict ()","title":"RankedConfigServices"},{"location":"api/#testcompose.models.config.config_services.RankedConfigServices.ranked_services","text":"","title":"ranked_services"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter","text":"Source code in testcompose/models/config/container_http_wait_parameter.py class HttpWaitParameter ( BaseModel ): http_port : int response_status_code : int = 200 startup_delay_time_ms : int = 20000 end_point : str = '/' use_https : bool = False @validator ( 'http_port' ) def validate_http_port ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer exposed Http port must be provided\" ) return v @validator ( 'end_point' ) def validate_end_point ( cls , v ): if not v or not isinstance ( v , str ): raise AttributeError ( \"A valide Http endpoint must be provided\" ) return v @validator ( 'response_status_code' ) def validate_response_status_code ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer Http response code must be provided\" ) return v @validator ( 'startup_delay_time_ms' ) def validate_startup_delay_time_ms ( cls , v ): if not v or not isinstance ( v , int ): return 20000 return v","title":"HttpWaitParameter"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.end_point","text":"","title":"end_point"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.http_port","text":"","title":"http_port"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.response_status_code","text":"","title":"response_status_code"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.startup_delay_time_ms","text":"","title":"startup_delay_time_ms"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.use_https","text":"","title":"use_https"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.validate_end_point","text":"Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'end_point' ) def validate_end_point ( cls , v ): if not v or not isinstance ( v , str ): raise AttributeError ( \"A valide Http endpoint must be provided\" ) return v","title":"validate_end_point()"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.validate_http_port","text":"Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'http_port' ) def validate_http_port ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer exposed Http port must be provided\" ) return v","title":"validate_http_port()"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.validate_response_status_code","text":"Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'response_status_code' ) def validate_response_status_code ( cls , v ): if not v or not isinstance ( v , int ): raise AttributeError ( \"A valide Integer Http response code must be provided\" ) return v","title":"validate_response_status_code()"},{"location":"api/#testcompose.models.config.container_http_wait_parameter.HttpWaitParameter.validate_startup_delay_time_ms","text":"Source code in testcompose/models/config/container_http_wait_parameter.py @validator ( 'startup_delay_time_ms' ) def validate_startup_delay_time_ms ( cls , v ): if not v or not isinstance ( v , int ): return 20000 return v","title":"validate_startup_delay_time_ms()"},{"location":"api/#testcompose.models.config.container_log_wait_parameters.LogWaitParameter","text":"Source code in testcompose/models/config/container_log_wait_parameters.py class LogWaitParameter ( BaseModel ): log_line_regex : str wait_timeout_ms : int = 60000 poll_interval_ms : int = 10000 @validator ( 'log_line_regex' ) def validate_log_line_regex ( cls , v ): if not v : raise AttributeError ( \"log_line_prefix must be set\" ) return v","title":"LogWaitParameter"},{"location":"api/#testcompose.models.config.container_log_wait_parameters.LogWaitParameter.log_line_regex","text":"","title":"log_line_regex"},{"location":"api/#testcompose.models.config.container_log_wait_parameters.LogWaitParameter.poll_interval_ms","text":"","title":"poll_interval_ms"},{"location":"api/#testcompose.models.config.container_log_wait_parameters.LogWaitParameter.wait_timeout_ms","text":"","title":"wait_timeout_ms"},{"location":"api/#testcompose.models.config.container_log_wait_parameters.LogWaitParameter.validate_log_line_regex","text":"Source code in testcompose/models/config/container_log_wait_parameters.py @validator ( 'log_line_regex' ) def validate_log_line_regex ( cls , v ): if not v : raise AttributeError ( \"log_line_prefix must be set\" ) return v","title":"validate_log_line_regex()"},{"location":"api/#testcompose.models.config.volume.VolumeSourceTypes","text":"VolumeSourceTypes(FILESYSTEM_SOURCE: str = 'filesystem', DOCKER_VOLUME_SOURCE: str = 'dockervolume') Source code in testcompose/models/config/volume.py @dataclass ( frozen = True ) class VolumeSourceTypes : FILESYSTEM_SOURCE : str = \"filesystem\" DOCKER_VOLUME_SOURCE : str = \"dockervolume\"","title":"VolumeSourceTypes"},{"location":"api/#testcompose.models.config.volume.VolumeSourceTypes.DOCKER_VOLUME_SOURCE","text":"","title":"DOCKER_VOLUME_SOURCE"},{"location":"api/#testcompose.models.config.volume.VolumeSourceTypes.FILESYSTEM_SOURCE","text":"","title":"FILESYSTEM_SOURCE"},{"location":"api/#testcompose.models.config.volume.VolumeMapping","text":"Source code in testcompose/models/config/volume.py class VolumeMapping ( BaseModel ): host : str container : str mode : str = 'ro' source : str = VolumeSourceTypes . DOCKER_VOLUME_SOURCE @validator ( 'mode' ) def validate_mode ( cls , v ): assert str ( v ) . lower () in [ 'ro' , 'rw' ] return v @validator ( 'source' ) def validate_source ( cls , v ): assert str ( v ) . lower () in [ 'filesystem' , 'dockervolume' ] return v @validator ( 'host' ) def validate_host ( cls , v ): if not v : raise AttributeError ( \"Volume Host option can not be empty or None\" ) return v @validator ( 'container' ) def validate_container ( cls , v ): if not v : raise AttributeError ( \"Volume container option can not be empty or None\" ) return v","title":"VolumeMapping"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.container","text":"","title":"container"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.host","text":"","title":"host"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.mode","text":"","title":"mode"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.source","text":"","title":"source"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.validate_container","text":"Source code in testcompose/models/config/volume.py @validator ( 'container' ) def validate_container ( cls , v ): if not v : raise AttributeError ( \"Volume container option can not be empty or None\" ) return v","title":"validate_container()"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.validate_host","text":"Source code in testcompose/models/config/volume.py @validator ( 'host' ) def validate_host ( cls , v ): if not v : raise AttributeError ( \"Volume Host option can not be empty or None\" ) return v","title":"validate_host()"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.validate_mode","text":"Source code in testcompose/models/config/volume.py @validator ( 'mode' ) def validate_mode ( cls , v ): assert str ( v ) . lower () in [ 'ro' , 'rw' ] return v","title":"validate_mode()"},{"location":"api/#testcompose.models.config.volume.VolumeMapping.validate_source","text":"Source code in testcompose/models/config/volume.py @validator ( 'source' ) def validate_source ( cls , v ): assert str ( v ) . lower () in [ 'filesystem' , 'dockervolume' ] return v","title":"validate_source()"},{"location":"api/#testcompose.models.container.running_container_attributes.PossibleContainerStates","text":"An enumeration. Source code in testcompose/models/container/running_container_attributes.py class PossibleContainerStates ( Enum ): RUNNING = 'exited' EXITED = 'running'","title":"PossibleContainerStates"},{"location":"api/#testcompose.models.container.running_container_attributes.PossibleContainerStates.EXITED","text":"","title":"EXITED"},{"location":"api/#testcompose.models.container.running_container_attributes.PossibleContainerStates.RUNNING","text":"","title":"RUNNING"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState","text":"Source code in testcompose/models/container/running_container_attributes.py class ContainerState ( BaseModel ): Status : str Running : bool Paused : bool Restarting : bool OOMKilled : bool Dead : bool Pid : int ExitCode : int Error : str StartedAt : str FinishedAt : str","title":"ContainerState"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Dead","text":"","title":"Dead"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Error","text":"","title":"Error"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.ExitCode","text":"","title":"ExitCode"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.FinishedAt","text":"","title":"FinishedAt"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.OOMKilled","text":"","title":"OOMKilled"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Paused","text":"","title":"Paused"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Pid","text":"","title":"Pid"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Restarting","text":"","title":"Restarting"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Running","text":"","title":"Running"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.StartedAt","text":"","title":"StartedAt"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Status","text":"","title":"Status"},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes","text":"Source code in testcompose/models/container/running_container_attributes.py class RunningContainerAttributes ( BaseModel ): Id : str State : ContainerState Platform : str NetworkSettings : ContainerNetworkSettings","title":"RunningContainerAttributes"},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.Id","text":"","title":"Id"},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.NetworkSettings","text":"","title":"NetworkSettings"},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.Platform","text":"","title":"Platform"},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.State","text":"","title":"State"},{"location":"api/#testcompose.models.network.network.NetworkComponents","text":"Source code in testcompose/models/network/network.py class NetworkComponents ( BaseModel ): Aliases : Optional [ List [ str ]] = None NetworkID : str EndpointID : str Gateway : str IPAddress : str","title":"NetworkComponents"},{"location":"api/#testcompose.models.network.network.NetworkComponents.Aliases","text":"","title":"Aliases"},{"location":"api/#testcompose.models.network.network.NetworkComponents.EndpointID","text":"","title":"EndpointID"},{"location":"api/#testcompose.models.network.network.NetworkComponents.Gateway","text":"","title":"Gateway"},{"location":"api/#testcompose.models.network.network.NetworkComponents.IPAddress","text":"","title":"IPAddress"},{"location":"api/#testcompose.models.network.network.NetworkComponents.NetworkID","text":"","title":"NetworkID"},{"location":"api/#testcompose.models.network.network.ContainerMappedPorts","text":"Source code in testcompose/models/network/network.py class ContainerMappedPorts ( BaseModel ): HostIp : str HostPort : str","title":"ContainerMappedPorts"},{"location":"api/#testcompose.models.network.network.ContainerMappedPorts.HostIp","text":"","title":"HostIp"},{"location":"api/#testcompose.models.network.network.ContainerMappedPorts.HostPort","text":"","title":"HostPort"},{"location":"api/#testcompose.models.network.network.ContainerNetworkSettings","text":"Source code in testcompose/models/network/network.py class ContainerNetworkSettings ( BaseModel ): Ports : Dict [ str , Any ] = dict () Networks : Dict [ str , NetworkComponents ]","title":"ContainerNetworkSettings"},{"location":"api/#testcompose.models.network.network.ContainerNetworkSettings.Networks","text":"","title":"Networks"},{"location":"api/#testcompose.models.network.network.ContainerNetworkSettings.Ports","text":"","title":"Ports"},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers","text":"DefaultNeworkDrivers() Source code in testcompose/models/network/network.py @dataclass ( frozen = True ) class DefaultNeworkDrivers : DEFAULT_BRIDGE_NETWORK = 'bridge' DEFAULT_HOST_NETWORK = 'host' DEFAULT_NULL_NETWORK = 'null'","title":"DefaultNeworkDrivers"},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers.DEFAULT_BRIDGE_NETWORK","text":"","title":"DEFAULT_BRIDGE_NETWORK"},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers.DEFAULT_HOST_NETWORK","text":"","title":"DEFAULT_HOST_NETWORK"},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers.DEFAULT_NULL_NETWORK","text":"","title":"DEFAULT_NULL_NETWORK"},{"location":"api/#testcompose.waiters.endpoint_waiters.EndpointWaiters","text":"Source code in testcompose/waiters/endpoint_waiters.py class EndpointWaiters : @staticmethod def _get_container_host_ip () -> str : \"\"\"The host IP where the container runs Returns: str: host IP \"\"\" return socket . gethostbyname ( socket . gethostname ()) @staticmethod def _check_endpoint ( wait_parameter : HttpWaitParameter , exposed_ports : Dict [ str , str ]) -> None : \"\"\"Endpoint health-check for a container. A running service with an exposed endpoint is queried and the response code is checked with the expected response code. Args: http_port (str): container service port status_code (int, optional): Defaults to 200. end_point (str, optional): Provided service endpoint. Defaults to \"/\". server_startup_time (int, optional): Expected wait time for the service to start. Defaults to 20. Returns: bool: Endpoint returned expected status code \"\"\" response_check : bool = True site_url : str = \"https://\" if wait_parameter . use_https else \"http://\" for _ in range ( 0 , 3 ): sleep ( wait_parameter . startup_delay_time_ms / 1000 ) try : host = EndpointWaiters . _get_container_host_ip () mapped_port = exposed_ports [ str ( wait_parameter . http_port )] site_url = site_url + f \" { host } : { mapped_port } / { wait_parameter . end_point . lstrip ( '/' ) } \" print ( site_url ) response = get ( url = site_url . rstrip ( \"/\" )) if response . status_code == wait_parameter . response_status_code : break except Exception as exc : response_check = False print ( \"HTTP_CHECK_ERROR: %s \" , exc ) if not response_check : raise RuntimeError ( f \"Http check on port { wait_parameter . http_port } failed\" ) return @staticmethod def wait_for_http ( wait_parameter : HttpWaitParameter , exposed_ports : Dict [ str , str ]) -> None : if wait_parameter : EndpointWaiters . _check_endpoint ( wait_parameter , exposed_ports )","title":"EndpointWaiters"},{"location":"api/#testcompose.waiters.endpoint_waiters.EndpointWaiters.wait_for_http","text":"Source code in testcompose/waiters/endpoint_waiters.py @staticmethod def wait_for_http ( wait_parameter : HttpWaitParameter , exposed_ports : Dict [ str , str ]) -> None : if wait_parameter : EndpointWaiters . _check_endpoint ( wait_parameter , exposed_ports )","title":"wait_for_http()"},{"location":"api/#testcompose.waiters.log_waiters.LogWaiter","text":"Source code in testcompose/waiters/log_waiters.py class LogWaiter : @staticmethod def search_container_logs ( test_container : Container , log_parameter : LogWaitParameter ) -> None : \"\"\"Search for a given predicate in the container log. Useful to check if a container is running and healthy Args: search_string (str): predicate to search in the log timeout (float, optional): Defaults to 300.0. interval (int, optional): Defaults to 1. Raises: ValueError: if a non string predicate is passed Returns: bool: True if the log contains the provided predicate \"\"\" if not log_parameter : return if not isinstance ( log_parameter . log_line_regex , str ): raise ValueError prog = re . compile ( log_parameter . log_line_regex , re . MULTILINE ) . search start = datetime . now () output : Optional [ Match [ str ]] = None while ( datetime . now () - start ) . total_seconds () < ( log_parameter . wait_timeout_ms / 1000 ): output = prog ( test_container . logs () . decode ()) if output : return if ( datetime . now () - start ) . total_seconds () > ( log_parameter . wait_timeout_ms / 1000 ): raise TimeoutError ( \"container %s did not emit logs satisfying predicate in %.3f seconds\" % ( test_container . name , float ( log_parameter . wait_timeout_ms or 60000 )) ) sleep ( log_parameter . poll_interval_ms / 1000 ) print ( \" %s \" , test_container . logs () . decode ()) return","title":"LogWaiter"},{"location":"api/#testcompose.waiters.log_waiters.LogWaiter.search_container_logs","text":"Search for a given predicate in the container log. Useful to check if a container is running and healthy Parameters: Name Type Description Default search_string str predicate to search in the log required timeout float Defaults to 300.0. required interval int Defaults to 1. required Exceptions: Type Description ValueError if a non string predicate is passed Returns: Type Description bool True if the log contains the provided predicate Source code in testcompose/waiters/log_waiters.py @staticmethod def search_container_logs ( test_container : Container , log_parameter : LogWaitParameter ) -> None : \"\"\"Search for a given predicate in the container log. Useful to check if a container is running and healthy Args: search_string (str): predicate to search in the log timeout (float, optional): Defaults to 300.0. interval (int, optional): Defaults to 1. Raises: ValueError: if a non string predicate is passed Returns: bool: True if the log contains the provided predicate \"\"\" if not log_parameter : return if not isinstance ( log_parameter . log_line_regex , str ): raise ValueError prog = re . compile ( log_parameter . log_line_regex , re . MULTILINE ) . search start = datetime . now () output : Optional [ Match [ str ]] = None while ( datetime . now () - start ) . total_seconds () < ( log_parameter . wait_timeout_ms / 1000 ): output = prog ( test_container . logs () . decode ()) if output : return if ( datetime . now () - start ) . total_seconds () > ( log_parameter . wait_timeout_ms / 1000 ): raise TimeoutError ( \"container %s did not emit logs satisfying predicate in %.3f seconds\" % ( test_container . name , float ( log_parameter . wait_timeout_ms or 60000 )) ) sleep ( log_parameter . poll_interval_ms / 1000 ) print ( \" %s \" , test_container . logs () . decode ()) return","title":"search_container_logs()"},{"location":"api/#testcompose.waiters.waiting_utils.WaitingUtils","text":"Source code in testcompose/waiters/waiting_utils.py class WaitingUtils : @staticmethod def container_status ( test_container : Container , status = \"running\" , delay_ms = 2000 , timeout_ms = 40000 ) -> bool : \"\"\"Method useful for checking a running container status to allow for fetching the latest attribute from the container Args: status (str, optional): Status to check for. Defaults to \"running\". delay (float, optional): Delay time before the next check. Defaults to 0.1. timeout (int, optional): Defaults to 40. \"\"\" print ( status ) if status . lower () not in [ PossibleContainerStates . EXITED . value , PossibleContainerStates . RUNNING . value , ]: raise ValueError ( \"Status must be one of running or exited\" ) start = datetime . now () while not ( status == ( RunningContainerAttributes ( ** test_container . attrs )) . State . Status ): if ( datetime . now () - start ) . total_seconds () * 1000 > timeout_ms : print ( f \"Container status { status } not obtained after { timeout_ms } ms\" ) return False sleep ( delay_ms / 1000 ) test_container . reload () print ( f \"Found Status { status } \" ) return True","title":"WaitingUtils"},{"location":"api/#testcompose.waiters.waiting_utils.WaitingUtils.container_status","text":"Method useful for checking a running container status to allow for fetching the latest attribute from the container Parameters: Name Type Description Default status str Status to check for. Defaults to \"running\". 'running' delay float Delay time before the next check. Defaults to 0.1. required timeout int Defaults to 40. required Source code in testcompose/waiters/waiting_utils.py @staticmethod def container_status ( test_container : Container , status = \"running\" , delay_ms = 2000 , timeout_ms = 40000 ) -> bool : \"\"\"Method useful for checking a running container status to allow for fetching the latest attribute from the container Args: status (str, optional): Status to check for. Defaults to \"running\". delay (float, optional): Delay time before the next check. Defaults to 0.1. timeout (int, optional): Defaults to 40. \"\"\" print ( status ) if status . lower () not in [ PossibleContainerStates . EXITED . value , PossibleContainerStates . RUNNING . value , ]: raise ValueError ( \"Status must be one of running or exited\" ) start = datetime . now () while not ( status == ( RunningContainerAttributes ( ** test_container . attrs )) . State . Status ): if ( datetime . now () - start ) . total_seconds () * 1000 > timeout_ms : print ( f \"Container status { status } not obtained after { timeout_ms } ms\" ) return False sleep ( delay_ms / 1000 ) test_container . reload () print ( f \"Found Status { status } \" ) return True","title":"container_status()"},{"location":"api/#testcompose.run_containers.RunContainers","text":"Run test containers Parameters: Name Type Description Default services RankedServices Ranked container services to be ran required wait_time_between_container_start float Default time to wait before spawning the next container. This is aimed at preventing starting containers too earlier before the container(s) they depend on has not fully started. Especially when they do not have a log predicate to search for or an http endpoint to check agains. Defaults to 20.0. 20.0 url_param ClientFromUrl Url parameters for connecting to the docker daemon. Defaults to ClientFromUrl(). ClientFromUrl(docker_host=None, version='auto', timeout=None, tls=None, user_agent=None, credstor_env=None, use_ssh_client=None, max_pool_size=None) env_param ClientFromEnv Environment variables parameter required to connect to the docker daemon. Defaults to ClientFromEnv(). ClientFromEnv(version='auto', timeout=None, max_pool_size=None, use_ssh_client=False, ssl_version=None, assert_hostname=None, environment=None) registry_login_param [type] Parameter providing docker registry login details. Defaults to Login(). Login(username=None, password=None, email=None, registry=None, reauth=False, dockercfg_path=None) Source code in testcompose/run_containers.py class RunContainers ( BaseDockerClient ): \"\"\"Run test containers Args: services (RankedServices): Ranked container services to be ran wait_time_between_container_start (float, optional): Default time to wait before spawning the next container. This is aimed at preventing starting containers too earlier before the container(s) they depend on has not fully started. Especially when they do not have a log predicate to search for or an http endpoint to check agains. Defaults to 20.0. url_param (ClientFromUrl, optional): Url parameters for connecting to the docker daemon. Defaults to ClientFromUrl(). env_param (ClientFromEnv, optional): Environment variables parameter required to connect to the docker daemon. Defaults to ClientFromEnv(). registry_login_param ([type], optional): Parameter providing docker registry login details. Defaults to Login(). \"\"\" def __init__ ( self , config_services : ConfigServices , ranked_services : RankedConfigServices , wait_time_between_container_start : float = 20.0 , registry_login_param = Login (), env_param : ClientFromEnv = ClientFromEnv (), url_param : ClientFromUrl = ClientFromUrl (), ) -> None : self . _container_network : ContainerNetwork self . _config_services : ConfigServices = config_services self . _ranked_config_services : RankedConfigServices = ranked_services self . running_containers = RunningContainers () self . _wait_time_between_container_start : float = wait_time_between_container_start self . _registry_login_param : Login = registry_login_param self . initialise_docker_client ( client_env_param = env_param , client_url_param = url_param ) @property def running_containers ( self ) -> RunningContainers : \"\"\"Running container objects Returns: RunningContainer: Running containers \"\"\" return self . _running_containers @running_containers . setter def running_containers ( self , containers : RunningContainers ): self . _running_containers = containers @property def unique_container_label ( self ) -> str : \"\"\"Unique test string label. Returns: str: unique label \"\"\" return self . _unique_container_label @unique_container_label . setter def unique_container_label ( self , label : str ): self . _unique_container_label = label def __enter__ ( self ) -> RunningContainers : return self . run () def __exit__ ( self , exc_type , exc_value , exc_tb ): self . stop_running_containers () if exc_tb and exc_type : logger . info ( \" %s [ %s ]: %s \" , exc_type , exc_value , exc_tb ) def run ( self ) -> RunningContainers : \"\"\"Run all Generic Test Containers Raises: AttributeError: When current container being stated had a record it was already running. TimeoutError: When a predicate could not be found in the log over a specified period of time RuntimeError: When an http endpoint did not return the expected specified status code. Exception: When an Unknown error occured during the process of starting a container. Returns: RunningContainer: running containers \"\"\" self . unique_container_label = uuid4 () . hex network_name = f \" { self . unique_container_label } _network\" self . _container_network = ContainerNetwork ( docker_client = self . docker_client , network_name = network_name ) processed_containers_services : Dict [ str , RunningContainer ] = dict () try : for rank in sorted ( self . _ranked_config_services . ranked_services . keys ()): service : Service = self . _config_services . services [ self . _ranked_config_services . ranked_services [ rank ] ] generic_container : GenericContainer = GenericContainer ( docker_client = self . docker_client ) generic_container . with_service ( service , processed_containers_services , self . _container_network . network_name ) . with_registry ( self . _registry_login_param ) . build () generic_container . test_network = self . _container_network generic_container . start () running_container = RunningContainer ( service_name = service . name , config_environment_variables = generic_container . container_environment_variables , generic_container = generic_container , ) processed_containers_services . update ({ service . name : running_container }) time . sleep ( self . _wait_time_between_container_start ) except Exception as exc : self . stop_running_containers ( RunningContainers ( running_containers = processed_containers_services )) logger . info ( \" %s \" , exc ) raise Exception logger . info ( \"The following containers were started: %s \" , list ( processed_containers_services . keys ())) self . running_containers = RunningContainers ( running_containers = processed_containers_services ) return self . running_containers def stop_running_containers ( self , running_containers : RunningContainers = RunningContainers ()): \"\"\"Stop all running containers\"\"\" try : _running_containers : RunningContainers = ( running_containers if running_containers . running_containers else self . running_containers ) for rank in sorted ( self . _ranked_config_services . ranked_services . keys (), reverse = True ): service_name : str = self . _ranked_config_services . ranked_services [ rank ] container : GenericContainer = _running_containers . running_containers [ service_name ] . generic_container # [service_name].generic_container container . stop () if not self . _container_network : self . _container_network = container . test_network logger . info ( \"Successfully stopped container: %s ( %s ): %s \" , service_name , str ( rank ), container . get_container_id (), ) time . sleep ( 5 ) finally : if not self . _container_network : raise AttributeError ( \"Test network could not be removed. Still dangling ...\" ) self . _container_network . remove_network () logger . info ( \"Run the ryuk container here!!!\" )","title":"RunContainers"},{"location":"api/#testcompose.run_containers.RunContainers.running_containers","text":"Running container objects Returns: Type Description RunningContainer Running containers","title":"running_containers"},{"location":"api/#testcompose.run_containers.RunContainers.unique_container_label","text":"Unique test string label. Returns: Type Description str unique label","title":"unique_container_label"},{"location":"api/#testcompose.run_containers.RunContainers.run","text":"Run all Generic Test Containers Exceptions: Type Description AttributeError When current container being stated had a record it was already running. TimeoutError When a predicate could not be found in the log over a specified period of time RuntimeError When an http endpoint did not return the expected specified status code. Exception When an Unknown error occured during the process of starting a container. Returns: Type Description RunningContainer running containers Source code in testcompose/run_containers.py def run ( self ) -> RunningContainers : \"\"\"Run all Generic Test Containers Raises: AttributeError: When current container being stated had a record it was already running. TimeoutError: When a predicate could not be found in the log over a specified period of time RuntimeError: When an http endpoint did not return the expected specified status code. Exception: When an Unknown error occured during the process of starting a container. Returns: RunningContainer: running containers \"\"\" self . unique_container_label = uuid4 () . hex network_name = f \" { self . unique_container_label } _network\" self . _container_network = ContainerNetwork ( docker_client = self . docker_client , network_name = network_name ) processed_containers_services : Dict [ str , RunningContainer ] = dict () try : for rank in sorted ( self . _ranked_config_services . ranked_services . keys ()): service : Service = self . _config_services . services [ self . _ranked_config_services . ranked_services [ rank ] ] generic_container : GenericContainer = GenericContainer ( docker_client = self . docker_client ) generic_container . with_service ( service , processed_containers_services , self . _container_network . network_name ) . with_registry ( self . _registry_login_param ) . build () generic_container . test_network = self . _container_network generic_container . start () running_container = RunningContainer ( service_name = service . name , config_environment_variables = generic_container . container_environment_variables , generic_container = generic_container , ) processed_containers_services . update ({ service . name : running_container }) time . sleep ( self . _wait_time_between_container_start ) except Exception as exc : self . stop_running_containers ( RunningContainers ( running_containers = processed_containers_services )) logger . info ( \" %s \" , exc ) raise Exception logger . info ( \"The following containers were started: %s \" , list ( processed_containers_services . keys ())) self . running_containers = RunningContainers ( running_containers = processed_containers_services ) return self . running_containers","title":"run()"},{"location":"api/#testcompose.run_containers.RunContainers.stop_running_containers","text":"Stop all running containers Source code in testcompose/run_containers.py def stop_running_containers ( self , running_containers : RunningContainers = RunningContainers ()): \"\"\"Stop all running containers\"\"\" try : _running_containers : RunningContainers = ( running_containers if running_containers . running_containers else self . running_containers ) for rank in sorted ( self . _ranked_config_services . ranked_services . keys (), reverse = True ): service_name : str = self . _ranked_config_services . ranked_services [ rank ] container : GenericContainer = _running_containers . running_containers [ service_name ] . generic_container # [service_name].generic_container container . stop () if not self . _container_network : self . _container_network = container . test_network logger . info ( \"Successfully stopped container: %s ( %s ): %s \" , service_name , str ( rank ), container . get_container_id (), ) time . sleep ( 5 ) finally : if not self . _container_network : raise AttributeError ( \"Test network could not be removed. Still dangling ...\" ) self . _container_network . remove_network () logger . info ( \"Run the ryuk container here!!!\" )","title":"stop_running_containers()"},{"location":"environment_variables/","text":"Environment Variables These are generally variables exposed on a running container as environment variables. The can be specified in the configuration as: ... environment : SOMEKEY_1 : some_value_1 SOMEKEY_2 : some_value_2 SOMEKEY_3 : some_value_3 ... The above variables SOMEKEY_1 , SOMEKEY_2 and SOMEKEY_3 will be available from within the container as environment variables. Place holder variables from another container can also be used in a container as environment variables as long as the container looking to expose such variables depends on the other contnainer. i.e services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" command : \"\" environment : APP2_KEY_1 : \"http://${app1.somekey_app1_1}-${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 The above placeholder variable http://${app1.somekey_app1_1}:${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592 of app2 will be translated at runtime as http://localhost-postgres/localtest:5592 . A primary requirement of this is that app2 depends on app1 !. Extra Environment Variables The following extra environment variables are included in all running containers regardless of whether they container environment variables of their own or not. These variables are: container_host_address : This special variable exposes the hostname of the contianer host. This is mostly uuseful when an external script needs to interact with the running docker images. It is particularly useful if the host has a different hostname other than localhost . external_port : Sometimes is is necessary to fix the host port to the running container. Even though this is greatly discouraged as it is advisable to allow TestContainers use random host port; some situations i.e for running Kafka docker images might require one to know the host port prior to starting the docker image. This is usually of the format external_port_PORT_NUMBER . As an example, assuming one would like to map the internal docker port 9092 with a random host port at container startup, one should specify this variable as external_port_9092 . Testcompose in this case assigns a random available port to be mapped with the port 9092 . - container_hostname : This is mainly the hostname of the docker image as seen within the created docker network. Usually, this is assigned the service name provided in the config. - self : This is a keyword use to mean the current image itself. E.g to specify the hostname of a service in its environment variable, one could write http://${self.container_hostname}/ping which will replace the plaeholder variable at startup. To use this set of variables, the yaml config above could be extended as shown: services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${app1.container_hostname}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 And this will be translated as http://${app1.docker_python_internal_host}/${app1.somekey_app1_3}:5592 -> http://app1-runtimehostname/localtest:5592 . Where app1-runtimehostname is determined at runtime. The variable combination of with the keywords might vary depending on what usage is intended. One could use a combination of self with all the other specifal variables e.g ${self.container_hostname} , ${self.container_host_address} and so on. As well as using it in a different form with self replaced by the name of a reference service. E.g for the config above, one could specify ${app1.container_hostname} which will be replaced with app1 since the service name is always used as the container hostname.","title":"Environment Variables"},{"location":"environment_variables/#environment-variables","text":"These are generally variables exposed on a running container as environment variables. The can be specified in the configuration as: ... environment : SOMEKEY_1 : some_value_1 SOMEKEY_2 : some_value_2 SOMEKEY_3 : some_value_3 ... The above variables SOMEKEY_1 , SOMEKEY_2 and SOMEKEY_3 will be available from within the container as environment variables. Place holder variables from another container can also be used in a container as environment variables as long as the container looking to expose such variables depends on the other contnainer. i.e services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" command : \"\" environment : APP2_KEY_1 : \"http://${app1.somekey_app1_1}-${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 The above placeholder variable http://${app1.somekey_app1_1}:${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592 of app2 will be translated at runtime as http://localhost-postgres/localtest:5592 . A primary requirement of this is that app2 depends on app1 !.","title":"Environment Variables"},{"location":"environment_variables/#extra-environment-variables","text":"The following extra environment variables are included in all running containers regardless of whether they container environment variables of their own or not. These variables are: container_host_address : This special variable exposes the hostname of the contianer host. This is mostly uuseful when an external script needs to interact with the running docker images. It is particularly useful if the host has a different hostname other than localhost . external_port : Sometimes is is necessary to fix the host port to the running container. Even though this is greatly discouraged as it is advisable to allow TestContainers use random host port; some situations i.e for running Kafka docker images might require one to know the host port prior to starting the docker image. This is usually of the format external_port_PORT_NUMBER . As an example, assuming one would like to map the internal docker port 9092 with a random host port at container startup, one should specify this variable as external_port_9092 . Testcompose in this case assigns a random available port to be mapped with the port 9092 . - container_hostname : This is mainly the hostname of the docker image as seen within the created docker network. Usually, this is assigned the service name provided in the config. - self : This is a keyword use to mean the current image itself. E.g to specify the hostname of a service in its environment variable, one could write http://${self.container_hostname}/ping which will replace the plaeholder variable at startup. To use this set of variables, the yaml config above could be extended as shown: services : - name : app1 image : \"node\" auto_remove : True command : \"\" environment : SOMEKEY_APP1_1 : localhost SOMEKEY_APP1_2 : postgres SOMEKEY_APP1_3 : localtest exposed_ports : - 5432 - name : app2 image : \"node\" auto_remove : True command : \"\" environment : APP2_KEY_1 : \"http://${app1.container_hostname}/${app1.somekey_app1_3}:5592\" , APP2_KEY_2 : a exposed_ports : - 4450 depends_on : - app1 And this will be translated as http://${app1.docker_python_internal_host}/${app1.somekey_app1_3}:5592 -> http://app1-runtimehostname/localtest:5592 . Where app1-runtimehostname is determined at runtime. The variable combination of with the keywords might vary depending on what usage is intended. One could use a combination of self with all the other specifal variables e.g ${self.container_hostname} , ${self.container_host_address} and so on. As well as using it in a different form with self replaced by the name of a reference service. E.g for the config above, one could specify ${app1.container_hostname} which will be replaced with app1 since the service name is always used as the container hostname.","title":"Extra Environment Variables"},{"location":"quickstart/","text":"QuickStart Create a config object from a dict. See examples here from testcompose.configs.service_config import Config run_config = Config ( test_services = ConfigServices ( ** config )) Or from a yaml file. Example here from testcompose.configs.parse_config import TestConfigParser from testcompose.configs.service_config import Config from testcompose.models.config.config_services import ConfigServices config = TestConfigParser . parse_config ( file_name = 'some-config.yaml' ) run_config = Config ( test_services = ConfigServices ( ** config )) Then let's run the containers and do some work with RunContainers ( config_services = config_services , ranked_services = running_config . ranked_config_services , ) as runner : assert runner app_container_srv_name = \"application\" app_service : RunningContainer = runner . running_containers [ app_container_srv_name ] app_env_vars = app_service . config_environment_variables mapped_port = app_service . generic_container . get_exposed_port ( \"8000\" ) print ( app_env_vars ) app_host = app_service . generic_container . get_container_host_ip () assert app_env_vars assert mapped_port assert app_host response = get ( url = f \"http:// { app_host } : { int ( mapped_port ) } /version\" ) assert response assert response . status_code == 200 assert response . text assert isinstance ( json . loads ( response . text ), dict ) and Voila !!! you are all set !","title":"QuickStart"},{"location":"quickstart/#quickstart","text":"Create a config object from a dict. See examples here from testcompose.configs.service_config import Config run_config = Config ( test_services = ConfigServices ( ** config )) Or from a yaml file. Example here from testcompose.configs.parse_config import TestConfigParser from testcompose.configs.service_config import Config from testcompose.models.config.config_services import ConfigServices config = TestConfigParser . parse_config ( file_name = 'some-config.yaml' ) run_config = Config ( test_services = ConfigServices ( ** config )) Then let's run the containers and do some work with RunContainers ( config_services = config_services , ranked_services = running_config . ranked_config_services , ) as runner : assert runner app_container_srv_name = \"application\" app_service : RunningContainer = runner . running_containers [ app_container_srv_name ] app_env_vars = app_service . config_environment_variables mapped_port = app_service . generic_container . get_exposed_port ( \"8000\" ) print ( app_env_vars ) app_host = app_service . generic_container . get_container_host_ip () assert app_env_vars assert mapped_port assert app_host response = get ( url = f \"http:// { app_host } : { int ( mapped_port ) } /version\" ) assert response assert response . status_code == 200 assert response . text assert isinstance ( json . loads ( response . text ), dict ) and Voila !!! you are all set !","title":"QuickStart"}]}