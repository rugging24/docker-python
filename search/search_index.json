{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>  </p>  Testcompose   <p>Testcompose provides an easy way of using docker containers for functional and integration testing. It allows for combination of more than one containers and allows for interactions with these containers from your test code without having to write extra scripts for such interactions. I.e providing a docker compose kind of functionality with the extra benefit of being able to fully control the containers from test codes.</p> <p>This is inspired by the testcontainers-python project and goes further to add a few additional functionalities to improve software integration testing while allowing the engineer to control every aspect of the test.</p>  <p>Install testcompose using pip:</p> <pre><code>$ pip install testcompose\n</code></pre> <p>testcompose requires Python 3.7+.</p> <p>You can either use a config file of the format:</p> <pre><code>services:\n  - name: db1\n    image: \"postgres:13\"\n    command: \"\"\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_DB: postgres\n      POSTGRES_PASSWORD: password\n    exposed_ports:\n      - 5432\n    volumes:\n      - host: \"data_volume\"\n        container: \"/data\"\n        mode: \"rw\"\n        source: \"dockervolume\" # possible values are `dockervolume` or `filesystem`\n    log_wait_parameters:\n      log_line_regex: \"database system is ready to accept connections\"\n      wait_timeout_ms: 30\n      poll_interval_ms: 2\n</code></pre> <p>Verify it as follows:</p> <pre><code>from testcompose.parse_config import TestConfigParser\nfrom testcompose.configs.service_config import Config\nfrom testcompose.run_containers import RunContainers\nfrom testcompose.models.config.config_services import ConfigServices, Service\n\nmy_test_service: ConfigServices = TestConfigParser.parse_config(\n    file_name='some-file-name'\n)\nmy_config: Config =  Config(test_services=my_test_service)\n\nwith RunContainers(\n        services=running_config.ranked_itest_config_services\n) as runner:\n    # Interract with the running containers\n\n    assert runner.running_containers\n\n    # Use some special parameters of the running containers\n\n    app_container = runner.running_containers[\"app_container_config_name\"].config_environment_variables\n\n    # Get the host port a certain exposed container port is mapped to\n    mapped_port = app_container.generic_container.get_exposed_port(\"8000\")\n\n    # where `port` is the exposed port of the container\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>For a run-through of all the basics, head over to the QuickStart.</p> <p>The Developer Interface provides a comprehensive API reference.</p>"},{"location":"api/","title":"Developer Reference","text":""},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient","title":"<code> testcompose.client.base_docker_client.BaseDockerClient            (ABC)         </code>","text":"Source code in <code>testcompose/client/base_docker_client.py</code> <pre><code>class BaseDockerClient(ABC):\n    def __init__(self, client_env_param: ClientFromEnv, client_url_param: ClientFromUrl) -&gt; None:\n        super(BaseDockerClient, self).__init__()\n        _client_url_param: ClientFromUrl = ClientFromUrl()\n        _client_env_param: ClientFromEnv = ClientFromEnv()\n\n        if client_env_param:\n            _client_env_param = client_env_param\n\n        if client_url_param:\n            _client_url_param = client_url_param\n\n        self.docker_client = self._init_docker_client(\n            client_url_param=_client_url_param, client_env_param=_client_env_param\n        )\n\n    @property\n    def docker_client(self) -&gt; DockerClient:\n        return self._docker_client\n\n    @docker_client.setter\n    def docker_client(self, client: DockerClient) -&gt; None:\n        self._docker_client: DockerClient = client\n\n    def _init_docker_client(\n        self, *, client_url_param: ClientFromUrl, client_env_param: ClientFromEnv\n    ) -&gt; DockerClient:\n        _docker_client: DockerClient = self._docker_client_from_env(client_env_param)\n        if client_url_param.docker_host:\n            _docker_client = self._docker_client_from_url(client_url_param)\n\n        _docker_client.ping()\n        return _docker_client\n\n    def _docker_client_from_env(self, client_env_param: ClientFromEnv) -&gt; DockerClient:\n        return docker.from_env(\n            version=client_env_param.version,\n            timeout=client_env_param.timeout,\n            max_pool_size=client_env_param.max_pool_size,\n            use_ssh_client=client_env_param.use_ssh_client,\n            ssl_version=client_env_param.ssl_version,\n            assert_hostname=client_env_param.assert_hostname,\n            environment=client_env_param.environment,\n        )\n\n    def _docker_client_from_url(self, client_url_param: ClientFromUrl) -&gt; DockerClient:\n        return DockerClient(\n            base_url=client_url_param.docker_host,\n            version=client_url_param.version,\n            timeout=client_url_param.timeout,\n            tls=client_url_param.tls,\n            user_agent=client_url_param.user_agent,\n            credstor_env=client_url_param.credstor_env,\n            use_ssh_client=client_url_param.use_ssh_client,\n            max_pool_size=client_url_param.max_pool_size,\n        )\n\n    def registry_login(self, login_credentials: Login) -&gt; None:\n        if login_credentials.registry:\n            self.docker_client.login(**login_credentials.dict())\n\n    def pull_docker_image(self, image_name: str) -&gt; None:\n        try:\n            self.docker_client.images.get(name=image_name)\n        except ImageNotFound:\n            self.docker_client.images.pull(repository=image_name)\n        except Exception:\n            print(traceback.format_exc())\n</code></pre>"},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient.docker_client","title":"<code>docker_client: DockerClient</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient.pull_docker_image","title":"<code>pull_docker_image(self, image_name: str) -&gt; None</code>","text":"Source code in <code>testcompose/client/base_docker_client.py</code> <pre><code>def pull_docker_image(self, image_name: str) -&gt; None:\n    try:\n        self.docker_client.images.get(name=image_name)\n    except ImageNotFound:\n        self.docker_client.images.pull(repository=image_name)\n    except Exception:\n        print(traceback.format_exc())\n</code></pre>"},{"location":"api/#testcompose.client.base_docker_client.BaseDockerClient.registry_login","title":"<code>registry_login(self, login_credentials: Login) -&gt; None</code>","text":"Source code in <code>testcompose/client/base_docker_client.py</code> <pre><code>def registry_login(self, login_credentials: Login) -&gt; None:\n    if login_credentials.registry:\n        self.docker_client.login(**login_credentials.dict())\n</code></pre>"},{"location":"api/#testcompose.configs.parse_config.TestConfigParser","title":"<code> testcompose.configs.parse_config.TestConfigParser        </code>","text":"Source code in <code>testcompose/configs/parse_config.py</code> <pre><code>class TestConfigParser:\n    @classmethod\n    def parse_config(cls, file_name: str) -&gt; ContainerServices:\n        \"\"\"parses and verifies test yaml config file\n\n        Args:\n            file_name (str): absolutel path of the config file\n\n        Raises:\n            FileNotFoundError: when config file not present\n            AttributeError: when config file is empty\n\n        Returns:\n            ConfigServices: A ConfigServices object with all named services in the config\n        \"\"\"\n        if not os.path.exists(file_name):\n            raise FileNotFoundError(f\"Config file {file_name} does not exist!!\")\n\n        contents: Dict[str, Any] = dict()\n        with open(file_name, 'r') as fh:\n            contents = yaml.safe_load(fh)\n\n        if not contents:\n            raise AttributeError(\"Config content can not be empty\")\n\n        services: Dict[str, ContainerService] = dict()\n        for service in contents[\"services\"]:\n            services.update({service[\"name\"]: ContainerService(**service)})\n\n        container_services: ContainerServices = ContainerServices(services=services)\n        return container_services\n</code></pre>"},{"location":"api/#testcompose.configs.parse_config.TestConfigParser.parse_config","title":"<code>parse_config(file_name: str) -&gt; ContainerServices</code>  <code>classmethod</code>","text":"<p>parses and verifies test yaml config file</p> <p>Parameters:</p>    Name Type Description Default     <code>file_name</code> <code>str</code> <p>absolutel path of the config file</p> required    <p>Exceptions:</p>    Type Description     <code>FileNotFoundError</code> <p>when config file not present</p>   <code>AttributeError</code> <p>when config file is empty</p>    <p>Returns:</p>    Type Description     <code>ConfigServices</code> <p>A ConfigServices object with all named services in the config</p>     Source code in <code>testcompose/configs/parse_config.py</code> <pre><code>@classmethod\ndef parse_config(cls, file_name: str) -&gt; ContainerServices:\n    \"\"\"parses and verifies test yaml config file\n\n    Args:\n        file_name (str): absolutel path of the config file\n\n    Raises:\n        FileNotFoundError: when config file not present\n        AttributeError: when config file is empty\n\n    Returns:\n        ConfigServices: A ConfigServices object with all named services in the config\n    \"\"\"\n    if not os.path.exists(file_name):\n        raise FileNotFoundError(f\"Config file {file_name} does not exist!!\")\n\n    contents: Dict[str, Any] = dict()\n    with open(file_name, 'r') as fh:\n        contents = yaml.safe_load(fh)\n\n    if not contents:\n        raise AttributeError(\"Config content can not be empty\")\n\n    services: Dict[str, ContainerService] = dict()\n    for service in contents[\"services\"]:\n        services.update({service[\"name\"]: ContainerService(**service)})\n\n    container_services: ContainerServices = ContainerServices(services=services)\n    return container_services\n</code></pre>"},{"location":"api/#testcompose.configs.service_config.Config","title":"<code> testcompose.configs.service_config.Config        </code>","text":"<p>This class consumes the model created from a config file. This is an important class that sets the precedence of how the different containers are to be started and stopped. Usually, the precedence are set correctly if the <code>depends_on</code> parameter of the config is set. Cyclic dependency will fail the test before it starts.</p> <p>Parameters:</p>    Name Type Description Default     <code>test_services</code> <code>ConfigServices</code> <p>model resulting from a parsed configuration file.</p> required     Source code in <code>testcompose/configs/service_config.py</code> <pre><code>class Config:\n    \"\"\"This class consumes the model created from a config file.\n    This is an important class that sets the precedence of how the\n    different containers are to be started and stopped. Usually, the\n    precedence are set correctly if the `depends_on` parameter of the\n    config is set. Cyclic dependency will fail the test before it starts.\n\n    Args:\n        test_services (ConfigServices): model resulting from a parsed configuration file.\n    \"\"\"\n\n    def __init__(self, test_services: ContainerServices) -&gt; None:\n        self._rank_test_services(test_services)\n\n    @property\n    def ranked_config_services(self) -&gt; RankedContainerServices:\n        \"\"\"Object containing the ordered services from the config\n\n        Returns:\n            RankedServices: ranked container services\n        \"\"\"\n        return self._ranked_it_services\n\n    @ranked_config_services.setter\n    def ranked_config_services(self, ranked_services: RankedContainerServices) -&gt; None:\n        self._ranked_it_services: RankedContainerServices = ranked_services\n\n    def _rank_test_services(self, test_services: ContainerServices) -&gt; None:\n        \"\"\"\n        Args:\n            test_services (ConfigServices): model resulting from a parsed configuration file.\n\n        Raises:\n            ValueError: raised if test_services is `null`\n            AttributeError: raised if no concreate networking is provided\n        \"\"\"\n        if not test_services:\n            logger.error(\"Config content can not be Null\")\n            raise ValueError\n\n        if not test_services.services:\n            logger.error(\"No service was found in the provided config\")\n            raise ValueError\n\n        _processed_containers: Dict[str, int] = self._compute_container_ranks(\n            ranked_services=dict(),\n            config_services=test_services,\n        )\n\n        _processed_containers_reversed: Dict[int, str] = {\n            rank: service for service, rank in _processed_containers.items()\n        }\n        self.ranked_config_services = RankedContainerServices(ranked_services=_processed_containers_reversed)\n\n    def _compute_container_ranks(\n        self,\n        *,\n        ranked_services: Dict[str, int],\n        config_services: ContainerServices,\n    ) -&gt; Dict[str, int]:\n        \"\"\"The main method that computes the ranking of the services specified\n        in the config.\n\n        Args:\n            ranked_services (Dict[str, int]): dict container service name and their assigned ranks\n            config_services (ConfigServices): config services generated from the supplied configuration file\n\n        Raises:\n            AttributeError: raised to prevent empty configuration properties to be passed to this function\n            ValueError: rasied when cyclic dependency is detected\n\n        Returns:\n            Dict[str, int]: A list of ranked service models.\n        \"\"\"\n        _ranked_services: Dict[str, int] = deepcopy(ranked_services)\n        if not config_services:\n            raise AttributeError(\"A valid config for test services must be provided\")\n\n        rank: int = len(ranked_services.keys())\n        if len(config_services.services.keys()) == len(ranked_services.keys()):\n            return ranked_services\n        else:\n            services: Dict[str, ContainerService] = {\n                x: y for x, y in config_services.services.items() if x not in _ranked_services\n            }\n            for service_name, service in services.items():\n                if not service.depends_on:\n                    _ranked_services.update({service_name: rank})\n                    rank += 1\n                else:\n                    if set(service.depends_on).issubset(\n                        _ranked_services.keys()\n                    ) and not self._check_cyclic_dependency(\n                        [config_services.services[x] for x in _ranked_services], service_name\n                    ):\n                        _ranked_services.update({service_name: rank})\n                        rank += 1\n                    elif not set(service.depends_on).issubset(list(config_services.services.keys())):\n                        raise AttributeError(\n                            f\"Invalid service name or dependencies detected: {service_name} &lt;=&gt; {set(service.depends_on)}\"\n                        )\n            return self._compute_container_ranks(\n                ranked_services=_ranked_services, config_services=config_services\n            )\n\n    @staticmethod\n    def _check_cyclic_dependency(\n        processed_services: List[ContainerService], dependent_service_name: str\n    ) -&gt; bool:\n        for service in processed_services:\n            if set([dependent_service_name]).issubset(service.depends_on):\n                return True\n        return False\n</code></pre>"},{"location":"api/#testcompose.configs.service_config.Config.ranked_config_services","title":"<code>ranked_config_services: RankedContainerServices</code>  <code>property</code> <code>writable</code>","text":"<p>Object containing the ordered services from the config</p> <p>Returns:</p>    Type Description     <code>RankedServices</code> <p>ranked container services</p>"},{"location":"api/#testcompose.containers.base_container.BaseContainer","title":"<code> testcompose.containers.base_container.BaseContainer        </code>","text":"Source code in <code>testcompose/containers/base_container.py</code> <pre><code>class BaseContainer:\n    def __init__(self) -&gt; None:\n        self._image_pull_policy: str = 'ALWAYS_PULL'\n\n    @property\n    def image(self) -&gt; str:\n        return self._image\n\n    @image.setter\n    def image(self, name: str) -&gt; None:\n        if not name:\n            raise ValueError(\"A valid Image entity must be provided\")\n        self._image: str = name\n\n    @property\n    def command(self) -&gt; str:\n        return self._command\n\n    @command.setter\n    def command(self, command: str) -&gt; None:\n        self._command: str = command\n\n    @property\n    def entry_point(self) -&gt; str:\n        return self._entry_point\n\n    @entry_point.setter\n    def entry_point(self, entry_point: str) -&gt; None:\n        self._entry_point: str = entry_point\n\n    @property\n    def host_name(self) -&gt; str:\n        return self._host_name\n\n    @host_name.setter\n    def host_name(self, host_name: str) -&gt; None:\n        self._host_name: str = host_name\n\n    @property\n    def network(self) -&gt; str:\n        return self._network\n\n    @network.setter\n    def network(self, network: str) -&gt; None:\n        self._network: str = network\n\n    @property\n    def http_waiter(self) -&gt; ContainerHttpWaitParameter:\n        return self._http_waiter\n\n    @http_waiter.setter\n    def http_waiter(self, http_waiter: ContainerHttpWaitParameter) -&gt; None:\n        self._http_waiter: ContainerHttpWaitParameter = http_waiter\n\n    @property\n    def log_waiter(self) -&gt; ContainerLogWaitParameter:\n        return self._log_waiter\n\n    @log_waiter.setter\n    def log_waiter(self, log_waiter: ContainerLogWaitParameter) -&gt; None:\n        self._log_waiter: ContainerLogWaitParameter = log_waiter\n\n    @property\n    def ports(self) -&gt; Dict[int, Any]:\n        return self._ports\n\n    @ports.setter\n    def ports(self, ports: List[str]) -&gt; None:\n        self._ports: Dict[int, Any] = self._exposed_ports(ports)\n\n    @property\n    def container_environment_variables(self) -&gt; Dict[str, Any]:\n        return self._container_environment_variables\n\n    @container_environment_variables.setter\n    def container_environment_variables(self, env: Dict[str, Any]) -&gt; None:\n        self._container_environment_variables: Dict[str, Any] = deepcopy(env)\n\n    @property\n    def volumes(self) -&gt; Dict[str, Dict[str, str]]:\n        return self._volumes\n\n    @volumes.setter\n    def volumes(self, volumes: List[ContainerVolumeMap]) -&gt; None:\n        self._volumes: Dict[str, Dict[str, str]] = self._container_volumes(volumes)\n\n    def with_service(\n        self,\n        service: ContainerService,\n        processed_containers_services: Dict[str, RunningContainer],\n        network: str,\n    ) -&gt; 'BaseContainer':\n        \"\"\"\n        The initialization method that converts a config\n        service into a Generic Container. It leverages other\n        internal _with methods to assign the complete container\n        properties.\n\n        Args:\n            service (Service): a config service\n            processed_containers_services (Dict[str, Any]): a dict of a service that\n                had already been initiated and the container is running.\n            network (str): the test network name, to attach all containers to.\n\n        Returns:\n            BaseServiceContainer\n        \"\"\"\n        self.image = service.image\n        self.command = service.command\n        (\n            substituted_env_variables,\n            modified_exposed_ports,\n        ) = ContainerUtils.replace_container_config_placeholders(\n            service_env_variables=service.environment,\n            running_containers=processed_containers_services,\n            service_name=service.name,\n            exposed_ports=service.exposed_ports,\n        )\n        self.container_environment_variables = substituted_env_variables\n        self.ports = modified_exposed_ports\n        self.http_waiter = service.http_wait_parameters  # type: ignore\n        self.volumes = service.volumes\n        self.entry_point = service.entrypoint  # type: ignore\n        self.log_waiter = service.log_wait_parameters  # type: ignore\n        self.host_name = service.name\n        self.network = network\n        return self\n\n    def _exposed_ports(self, ports: Optional[List[str]]) -&gt; Dict[int, Any]:\n        \"\"\"List of exposed port to be assigned random port\n        numbers on the host. Random ports are exposed to the\n        host. A fixed port can be assigned on the host by providing\n        the port in the format **[host_port:container_port]**\n\n        Args:\n            ports (Optional[List[str]]): list of container exposed ports\n        \"\"\"\n        exposed_ports: Dict[int, Any] = dict()\n        if ports:\n            for port in ports:\n                _ports: List[str] = self._generate_exposed_ports(re.sub(r\"(\\s)\", \"\", port))\n                for _port in _ports:\n                    if len(_port.split(\":\")) == 2:\n                        exposed_ports[int(_ports[1])] = int(_ports[0])\n                    else:\n                        exposed_ports[int(_port)] = None\n        return exposed_ports\n\n    def _generate_exposed_ports(self, port: str) -&gt; List[str]:\n        matches: List[Any] = re.findall(r\"\\-\", port)\n        unprocessed_ports: List[str] = list()\n        if len(matches) == 0:\n            unprocessed_ports.append(port)\n        elif len(matches) == 1:\n            start, end = str(port).split(\"-\")\n            if int(end) &lt;= int(start):\n                raise AttributeError(\n                    f\"Start exposed port {start} must be less than end exposed port {end} for port ranges!\"\n                )\n            unprocessed_ports = [str(x) for x in range(int(start), int(end) + 1)]\n        else:\n            raise AttributeError(\"Allowed exposed port format is host:container or port1 - port2\")\n        return unprocessed_ports\n\n    def _container_volumes(\n        self, volumes: Optional[List[ContainerVolumeMap]] = None\n    ) -&gt; Dict[str, Dict[str, str]]:\n        \"\"\"A list of volume mappings to be mounted in the container.\n\n            VolumeMapping:\n                host: host volume path or a docker volume name\n                container: path to mount the host volume in the container\n                mode: volume mode [ro|rw]\n                source: source of the volume [filesystem|dockervolume]\n                        filesystem: a file or directory to be mounted\n                        dockervolume: a docker volume (existing or to be created)\n\n        Args:\n            volumes (Optional[List[VolumeMapping]]): Optional list of volumes to mount on the container\n        \"\"\"\n        mapped_volumes: Dict[str, Dict[str, str]] = dict()\n        if volumes:\n            for vol in volumes:\n                host_bind: Optional[str] = None\n                if vol.source == VolumeSourceTypes.DOCKER_VOLUME_SOURCE:\n                    host_bind = vol.host\n                elif vol.source == VolumeSourceTypes.FILESYSTEM_SOURCE:\n                    host_bind = str(pathlib.Path(vol.host).absolute())\n                if not host_bind:\n                    raise ValueError(\"Volume source can only be one of local|docker\")\n                mapped_volumes[host_bind] = {\"bind\": vol.container, \"mode\": vol.mode}\n        return mapped_volumes\n\n    @abstractmethod\n    def start(self) -&gt; None:\n        raise NotImplementedError\n\n    @abstractmethod\n    def stop(self, force=True, delete_volume=True) -&gt; None:\n        raise NotImplementedError\n</code></pre>"},{"location":"api/#testcompose.containers.base_container.BaseContainer.command","title":"<code>command: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.container_environment_variables","title":"<code>container_environment_variables: Dict[str, Any]</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.entry_point","title":"<code>entry_point: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.host_name","title":"<code>host_name: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.http_waiter","title":"<code>http_waiter: ContainerHttpWaitParameter</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.image","title":"<code>image: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.log_waiter","title":"<code>log_waiter: ContainerLogWaitParameter</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.network","title":"<code>network: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.ports","title":"<code>ports: Dict[int, Any]</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.volumes","title":"<code>volumes: Dict[str, Dict[str, str]]</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.base_container.BaseContainer.start","title":"<code>start(self) -&gt; None</code>","text":"Source code in <code>testcompose/containers/base_container.py</code> <pre><code>@abstractmethod\ndef start(self) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#testcompose.containers.base_container.BaseContainer.stop","title":"<code>stop(self, force = True, delete_volume = True) -&gt; None</code>","text":"Source code in <code>testcompose/containers/base_container.py</code> <pre><code>@abstractmethod\ndef stop(self, force=True, delete_volume=True) -&gt; None:\n    raise NotImplementedError\n</code></pre>"},{"location":"api/#testcompose.containers.base_container.BaseContainer.with_service","title":"<code>with_service(self, service: ContainerService, processed_containers_services: Dict[str, testcompose.models.container.running_container.RunningContainer], network: str) -&gt; BaseContainer</code>","text":"<p>The initialization method that converts a config service into a Generic Container. It leverages other internal _with methods to assign the complete container properties.</p> <p>Parameters:</p>    Name Type Description Default     <code>service</code> <code>Service</code> <p>a config service</p> required   <code>processed_containers_services</code> <code>Dict[str, Any]</code> <p>a dict of a service that had already been initiated and the container is running.</p> required   <code>network</code> <code>str</code> <p>the test network name, to attach all containers to.</p> required    <p>Returns:</p>    Type Description     <code>BaseContainer</code> <p>BaseServiceContainer</p>     Source code in <code>testcompose/containers/base_container.py</code> <pre><code>def with_service(\n    self,\n    service: ContainerService,\n    processed_containers_services: Dict[str, RunningContainer],\n    network: str,\n) -&gt; 'BaseContainer':\n    \"\"\"\n    The initialization method that converts a config\n    service into a Generic Container. It leverages other\n    internal _with methods to assign the complete container\n    properties.\n\n    Args:\n        service (Service): a config service\n        processed_containers_services (Dict[str, Any]): a dict of a service that\n            had already been initiated and the container is running.\n        network (str): the test network name, to attach all containers to.\n\n    Returns:\n        BaseServiceContainer\n    \"\"\"\n    self.image = service.image\n    self.command = service.command\n    (\n        substituted_env_variables,\n        modified_exposed_ports,\n    ) = ContainerUtils.replace_container_config_placeholders(\n        service_env_variables=service.environment,\n        running_containers=processed_containers_services,\n        service_name=service.name,\n        exposed_ports=service.exposed_ports,\n    )\n    self.container_environment_variables = substituted_env_variables\n    self.ports = modified_exposed_ports\n    self.http_waiter = service.http_wait_parameters  # type: ignore\n    self.volumes = service.volumes\n    self.entry_point = service.entrypoint  # type: ignore\n    self.log_waiter = service.log_wait_parameters  # type: ignore\n    self.host_name = service.name\n    self.network = network\n    return self\n</code></pre>"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork","title":"<code> testcompose.containers.container_network.ContainerNetwork        </code>","text":"<p>Network management for running container.This class ensures all containers in the same test belong to the same network. Contians utility to create and cleanup network.</p> <p>Parameters:</p>    Name Type Description Default     <code>docker_client</code> <code>DockerClient</code> <p>Docker client</p> required   <code>network_name</code> <code>str</code> <p>Name of test network</p> required     Source code in <code>testcompose/containers/container_network.py</code> <pre><code>class ContainerNetwork:\n    \"\"\"Network management for running container.This class ensures\n    all containers in the same test belong to the same network.\n    Contians utility to create and cleanup network.\n\n    Args:\n        docker_client (DockerClient): Docker client\n        network_name (str): Name of test network\n    \"\"\"\n\n    def __init__(self, docker_client: DockerClient, network_name: str) -&gt; None:\n        self._docker_client: DockerClient = docker_client\n        self._assign_group_network(network_name)\n\n    @property\n    def network(self) -&gt; Network:\n        \"\"\"Network Object\n\n        Returns:\n            docker.models.networks.Network: container network object\n        \"\"\"\n        return self._container_network\n\n    @network.setter\n    def network(self, network: Network) -&gt; None:\n        self._container_network: Network = network\n\n    @property\n    def name(self) -&gt; Optional[str]:\n        return self.network.name\n\n    @property\n    def network_id(self) -&gt; Optional[str]:\n        return self.network.short_id\n\n    def remove_network(self) -&gt; None:\n        try:\n            if self.network.name not in ['bridge', 'none', 'host']:\n                self.network.remove()\n        except Exception as exc:\n            print(f\"Test network could not be removed. Still dangling ... {exc}\")\n\n    def _assign_group_network(\n        self,\n        network_name: str,\n        label: Dict[str, str] = dict(),\n        driver: str = DefaultNeworkDrivers.DEFAULT_BRIDGE_NETWORK,\n    ) -&gt; None:\n        try:\n            self.network = (self._docker_client.networks.list(names=[network_name]))[0]  # type: ignore\n        except Exception:\n            self.network = self._docker_client.networks.create(\n                name=network_name,\n                driver=driver,\n                check_duplicate=True,\n                internal=False,\n                labels=label or None,\n                enable_ipv6=False,\n                attachable=True,\n                scope='local',\n            )  # type: ignore\n</code></pre>"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.name","title":"<code>name: Optional[str]</code>  <code>property</code> <code>readonly</code>","text":""},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.network","title":"<code>network: Network</code>  <code>property</code> <code>writable</code>","text":"<p>Network Object</p> <p>Returns:</p>    Type Description     <code>docker.models.networks.Network</code> <p>container network object</p>"},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.network_id","title":"<code>network_id: Optional[str]</code>  <code>property</code> <code>readonly</code>","text":""},{"location":"api/#testcompose.containers.container_network.ContainerNetwork.remove_network","title":"<code>remove_network(self) -&gt; None</code>","text":"Source code in <code>testcompose/containers/container_network.py</code> <pre><code>def remove_network(self) -&gt; None:\n    try:\n        if self.network.name not in ['bridge', 'none', 'host']:\n            self.network.remove()\n    except Exception as exc:\n        print(f\"Test network could not be removed. Still dangling ... {exc}\")\n</code></pre>"},{"location":"api/#testcompose.containers.container_utils.ContainerUtils","title":"<code> testcompose.containers.container_utils.ContainerUtils        </code>","text":"Source code in <code>testcompose/containers/container_utils.py</code> <pre><code>class ContainerUtils:\n    @staticmethod\n    def replace_container_config_placeholders(\n        service_env_variables: Dict[str, Any],\n        running_containers: Dict[str, RunningContainer],\n        service_name: str,\n        exposed_ports: List[str],\n    ) -&gt; Tuple[Dict[str, Any], List[str]]:\n        \"\"\"Utility method to replace placeholders in the service containers.\n        Placeholders are usually of the form *${container_name.containerenv_variable}*.\n\n        Args:\n            service_env_variables (Dict[str, Any]): Dict of config environment variables\n            running_containers Dict[str, RunningContainer]: Running container object\n            service_name (str): service name as specified in the config\n            exposed_ports (List[str]): container exposed ports\n\n        Raises:\n            ValueError: when a placeholder variable is not of the form service_name.variable_name\n            AttributeError: When a service name could not be found in the list of services obtained from the\n                            provided config file.\n\n        Returns:\n            Tuple[Dict[str, Any], List[str]]: A tuple of `env_config` and `exposed_ports`\n        \"\"\"\n        pattern: str = \"\\\\$\\\\{([^}]*)}\"\n        substituted_env_variables: Dict[str, Any] = copy(service_env_variables)\n        modified_exposed_ports: List[str] = deepcopy(exposed_ports)\n        cmpl = re.compile(pattern=pattern).findall\n        for k, v in service_env_variables.items():\n            if isinstance(v, str):\n                replaced_variable: str = v\n                for occurence in cmpl(v):\n                    if len(str(occurence).split(\".\")) != 2:\n                        raise ValueError\n                    container_name, variable_name = str(occurence).split(\".\")\n                    value = None\n                    value, _exposed_ports = ContainerUtils._external_ports_variables(\n                        running_containers,\n                        service_name,\n                        container_name,\n                        variable_name,\n                        modified_exposed_ports,\n                    )\n                    if _exposed_ports:\n                        modified_exposed_ports = deepcopy(_exposed_ports)\n                    replaced_variable = replaced_variable.replace(f\"${{{occurence}}}\", str(value))\n                substituted_env_variables[k] = replaced_variable\n        return substituted_env_variables, modified_exposed_ports\n\n    @staticmethod\n    def _get_free_host_port() -&gt; str:\n        \"\"\"Get a free random port number from the container host\n\n        Returns:\n            str: port number\n        \"\"\"\n        _socket = socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM)\n        _socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEPORT, 1)\n        _socket.settimeout(2)\n        _socket.bind((\"\", 0))\n        _, port = _socket.getsockname()\n        _socket.close()\n        return port\n\n    @staticmethod\n    def _external_ports_variables(\n        running_containers: Dict[str, RunningContainer],\n        service_name: str,\n        container_name: str,\n        variable_name: str,\n        exposed_ports: List[str] = list(),\n    ) -&gt; Tuple[Optional[str], List[str]]:\n        value: Optional[str] = None\n        _exposed_ports: List[str] = list()\n        if container_name.lower() == SupportedPlaceholders.SELF_HOST or variable_name.lower() in [\n            SupportedPlaceholders.CONTAINER_HOSTNAME,\n            SupportedPlaceholders.EXTERNAL_PORT,\n            SupportedPlaceholders.CONTAINER_HOST_ADDRESS,\n        ]:\n            if (\n                container_name.lower() == SupportedPlaceholders.SELF_HOST\n                and variable_name.lower() == SupportedPlaceholders.CONTAINER_HOSTNAME\n            ):\n                value = service_name\n            elif (\n                container_name.lower() != SupportedPlaceholders.SELF_HOST\n                and variable_name.lower() == SupportedPlaceholders.CONTAINER_HOSTNAME\n            ):\n                value = container_name\n            else:\n                if variable_name.lower().startswith(SupportedPlaceholders.EXTERNAL_PORT):\n                    value, _exposed_ports = ContainerUtils._external_port_variables(\n                        variable_name, exposed_ports\n                    )\n                elif variable_name.lower() == SupportedPlaceholders.CONTAINER_HOST_ADDRESS:\n                    value = socket.gethostbyname(socket.gethostname())\n        else:\n            value = running_containers[\n                f\"{container_name.lower()}\"\n            ].generic_container.container_environment_variables[f\"{variable_name.upper()}\"]\n\n        return value, _exposed_ports\n\n    @staticmethod\n    def _external_port_variables(variable_name: str, exposed_ports: List[str]) -&gt; Tuple[str, List[str]]:\n        _exposed_ports: List[str] = deepcopy(exposed_ports)\n        container_port: str = re.sub(SupportedPlaceholders.EXTERNAL_PORT + \"_\", \"\", variable_name)\n        host_port: str = ContainerUtils._get_free_host_port()\n        if container_port and container_port not in exposed_ports:\n            raise AttributeError(\n                f\"self.hostport_{container_port} must be a valid supplied exposed_ports value!\"\n            )\n        _exposed_ports.remove(container_port)\n        _exposed_ports.append(f\"{host_port}:{container_port}\")\n        value: str = str(host_port)\n        return value, _exposed_ports\n</code></pre>"},{"location":"api/#testcompose.containers.container_utils.ContainerUtils.replace_container_config_placeholders","title":"<code>replace_container_config_placeholders(service_env_variables: Dict[str, Any], running_containers: Dict[str, testcompose.models.container.running_container.RunningContainer], service_name: str, exposed_ports: List[str]) -&gt; Tuple[Dict[str, Any], List[str]]</code>  <code>staticmethod</code>","text":"<p>Utility method to replace placeholders in the service containers. Placeholders are usually of the form ${container_name.containerenv_variable}.</p> <p>Parameters:</p>    Name Type Description Default     <code>service_env_variables</code> <code>Dict[str, Any]</code> <p>Dict of config environment variables</p> required   <code>running_containers</code> <code>Dict[str, RunningContainer]</code> <p>Running container object</p> required   <code>service_name</code> <code>str</code> <p>service name as specified in the config</p> required   <code>exposed_ports</code> <code>List[str]</code> <p>container exposed ports</p> required    <p>Exceptions:</p>    Type Description     <code>ValueError</code> <p>when a placeholder variable is not of the form service_name.variable_name</p>   <code>AttributeError</code> <p>When a service name could not be found in the list of services obtained from the             provided config file.</p>    <p>Returns:</p>    Type Description     <code>Tuple[Dict[str, Any], List[str]]</code> <p>A tuple of <code>env_config</code> and <code>exposed_ports</code></p>     Source code in <code>testcompose/containers/container_utils.py</code> <pre><code>@staticmethod\ndef replace_container_config_placeholders(\n    service_env_variables: Dict[str, Any],\n    running_containers: Dict[str, RunningContainer],\n    service_name: str,\n    exposed_ports: List[str],\n) -&gt; Tuple[Dict[str, Any], List[str]]:\n    \"\"\"Utility method to replace placeholders in the service containers.\n    Placeholders are usually of the form *${container_name.containerenv_variable}*.\n\n    Args:\n        service_env_variables (Dict[str, Any]): Dict of config environment variables\n        running_containers Dict[str, RunningContainer]: Running container object\n        service_name (str): service name as specified in the config\n        exposed_ports (List[str]): container exposed ports\n\n    Raises:\n        ValueError: when a placeholder variable is not of the form service_name.variable_name\n        AttributeError: When a service name could not be found in the list of services obtained from the\n                        provided config file.\n\n    Returns:\n        Tuple[Dict[str, Any], List[str]]: A tuple of `env_config` and `exposed_ports`\n    \"\"\"\n    pattern: str = \"\\\\$\\\\{([^}]*)}\"\n    substituted_env_variables: Dict[str, Any] = copy(service_env_variables)\n    modified_exposed_ports: List[str] = deepcopy(exposed_ports)\n    cmpl = re.compile(pattern=pattern).findall\n    for k, v in service_env_variables.items():\n        if isinstance(v, str):\n            replaced_variable: str = v\n            for occurence in cmpl(v):\n                if len(str(occurence).split(\".\")) != 2:\n                    raise ValueError\n                container_name, variable_name = str(occurence).split(\".\")\n                value = None\n                value, _exposed_ports = ContainerUtils._external_ports_variables(\n                    running_containers,\n                    service_name,\n                    container_name,\n                    variable_name,\n                    modified_exposed_ports,\n                )\n                if _exposed_ports:\n                    modified_exposed_ports = deepcopy(_exposed_ports)\n                replaced_variable = replaced_variable.replace(f\"${{{occurence}}}\", str(value))\n            substituted_env_variables[k] = replaced_variable\n    return substituted_env_variables, modified_exposed_ports\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer","title":"<code> testcompose.containers.generic_container.GenericContainer            (BaseContainer)         </code>","text":"Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>class GenericContainer(BaseContainer):\n    def __init__(self) -&gt; None:\n        super().__init__()\n\n    @property\n    def container_network(self) -&gt; ContainerNetwork:\n        return self._container_network\n\n    @container_network.setter\n    def container_network(self, network: ContainerNetwork) -&gt; None:\n        self._container_network: ContainerNetwork = network\n\n    @property\n    def container(self) -&gt; Container:\n        return self._container\n\n    @container.setter\n    def container(self, container: Container) -&gt; None:\n        self._container: Container = container\n\n    @property\n    def container_attr(self) -&gt; RunningContainerAttributes:\n        \"\"\"Running container attributes\n\n        Returns:\n            RunningContainerAttributes: Container attribute object\n        \"\"\"\n        return self._container_attr\n\n    @container_attr.setter\n    def container_attr(self, atrr: Dict[str, Any]) -&gt; None:\n        \"\"\"Running container attributes. Execute reload() to refresh this\n        property.\n\n        Args:\n            atrr (RunningContainerAttributes): container attributes\n        \"\"\"\n        self._container_attr: RunningContainerAttributes = RunningContainerAttributes(**atrr)\n\n    def start(self, docker_client: DockerClient) -&gt; Container:\n        \"\"\"Start a container\"\"\"\n        if not docker_client.ping():\n            raise RuntimeError(\"Docker Client not Running. Please check your docker settings and try again\")\n\n        return docker_client.containers.run(\n            image=self.image,\n            command=self.command,\n            detach=True,\n            environment=self.container_environment_variables,\n            ports=self.ports,\n            volumes=self.volumes,\n            entrypoint=self.entry_point,\n            auto_remove=True,\n            remove=True,\n            network=self.network,\n            hostname=self.host_name,\n        )  # type: ignore\n\n    def check_container_health(self, docker_client: DockerClient, timeout: int = 120) -&gt; None:\n        start_time: datetime = datetime.now()\n        while (datetime.now() - start_time).total_seconds() &lt; timeout:\n            logger.info(\n                f\"Waiting for containe:{self.container.name} status to \\\n                change from {self.container.status} to {PossibleContainerStates.RUNNING}\"\n            )\n            self.container.reload()\n            if self.container.status == PossibleContainerStates.RUNNING:\n                logger.info(f\"Container:{self.container.name} status changed to {self.container.status}\")\n                break\n            sleep(2)\n\n        self.reload(docker_client, self.get_container_id())\n        if self.container.status != PossibleContainerStates.RUNNING:\n            for line in self.container.logs(stream=True):\n                logger.debug(line.decode())\n            raise RuntimeError(f\"Container is in an unwanted state {self.container.status}\")\n\n        self.reload(docker_client, self.get_container_id())\n\n        LogWaiter.search_container_logs(docker_client, self.container, self.log_waiter)\n\n        self.reload(docker_client, self.get_container_id())\n\n        if self.http_waiter:\n            mapped_http_port: Dict[str, str] = dict()\n            mapped_http_port[str(self.http_waiter.http_port)] = self.get_exposed_port(  # type: ignore\n                str(self.http_waiter.http_port)\n            )\n            EndpointWaiters.wait_for_http(\n                docker_client,\n                self.get_container_id(),  # type: ignore\n                self.http_waiter,\n                mapped_http_port,  # type: ignore\n            )\n\n    def stop(self, force=True, delete_volume=True) -&gt; None:\n        \"\"\"Stop a running container\n        Args:\n            force (bool, optional): [description]. Defaults to True.\n            delete_volume (bool, optional): [description]. Defaults to True.\n        \"\"\"\n        try:\n            if self.container:\n                self.container.remove(v=delete_volume, force=force)\n        except APIError as exc:\n            logger.error(exc)\n\n    def reload(self, docker_client, container_id) -&gt; None:\n        \"\"\"Reload the attributes of a running container\"\"\"\n        if is_container_still_running(docker_client, container_id):\n            self.container.reload()\n            self.container_attr = self.container.attrs  # type: ignore\n\n    def get_exposed_port(self, port: str) -&gt; Optional[str]:\n        \"\"\"Get host port bound to the container exposed port\n\n        Args:\n            port (str): container exposed port\n\n        Returns:\n            str: Host port bound to the container exposed port\n        \"\"\"\n        if not port:\n            return None\n        return self._get_mapped_container_ports([port])[port]\n\n    def _get_mapped_container_ports(self, exposed_ports: List[str]) -&gt; Dict[str, str]:\n        \"\"\"Host port bound to the container returned as a k/v of the\n        container exposed port as key and the host bound port as the value.\n\n        Args:\n            ports (List[str]): List of container exposed port to be mapped to host port\n\n        Returns:\n            Dict[str, str]: Mapped container-host ports.\n        \"\"\"\n        mapped_ports: Dict[str, str] = dict()\n        ports: Dict[str, Any] = self.container_attr.NetworkSettings.Ports\n        for port in ports:\n            container_port: str = re.sub(\"[^0-9]\", \"\", port)\n            if container_port in exposed_ports and ports[port] and isinstance(ports[port], list):\n                host_ports: ContainerMappedPorts = ContainerMappedPorts(**(ports[port][0]))\n                mapped_ports.update({container_port: host_ports.HostPort})\n        return mapped_ports\n\n    def get_container_id(self) -&gt; Optional[str]:\n        \"\"\"Container id\n\n        Returns:\n            Optional[str]: Container Id\n        \"\"\"\n        if self.container:\n            return self.container.id\n        return None\n\n    def get_container_host_ip(self) -&gt; str:\n        \"\"\"Container Host IP address\n\n        Returns:\n            str: container host IP Address\n        \"\"\"\n        return socket.gethostbyname(socket.gethostname())\n\n    def exe_command(self, command: Union[str, List[str]]) -&gt; Tuple[int, ByteString]:\n        \"\"\"Execute a command inside a container after it has started running.\n\n        Args:\n            command (Union[str, List[str]]): command to run in the container\n\n        Raises:\n            RuntimeError: when the container object is not set\n\n        Returns:\n            Tuple[int, ByteString]: A tuple of (exit_code, output)\n        \"\"\"\n        if not self.container:\n            raise RuntimeError(\"Container must already be running to exec a command\")\n        return self.container.exec_run(cmd=command)\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.container","title":"<code>container: Container</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.generic_container.GenericContainer.container_attr","title":"<code>container_attr: RunningContainerAttributes</code>  <code>property</code> <code>writable</code>","text":"<p>Running container attributes</p> <p>Returns:</p>    Type Description     <code>RunningContainerAttributes</code> <p>Container attribute object</p>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.container_network","title":"<code>container_network: ContainerNetwork</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.containers.generic_container.GenericContainer.check_container_health","title":"<code>check_container_health(self, docker_client: DockerClient, timeout: int = 120) -&gt; None</code>","text":"Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def check_container_health(self, docker_client: DockerClient, timeout: int = 120) -&gt; None:\n    start_time: datetime = datetime.now()\n    while (datetime.now() - start_time).total_seconds() &lt; timeout:\n        logger.info(\n            f\"Waiting for containe:{self.container.name} status to \\\n            change from {self.container.status} to {PossibleContainerStates.RUNNING}\"\n        )\n        self.container.reload()\n        if self.container.status == PossibleContainerStates.RUNNING:\n            logger.info(f\"Container:{self.container.name} status changed to {self.container.status}\")\n            break\n        sleep(2)\n\n    self.reload(docker_client, self.get_container_id())\n    if self.container.status != PossibleContainerStates.RUNNING:\n        for line in self.container.logs(stream=True):\n            logger.debug(line.decode())\n        raise RuntimeError(f\"Container is in an unwanted state {self.container.status}\")\n\n    self.reload(docker_client, self.get_container_id())\n\n    LogWaiter.search_container_logs(docker_client, self.container, self.log_waiter)\n\n    self.reload(docker_client, self.get_container_id())\n\n    if self.http_waiter:\n        mapped_http_port: Dict[str, str] = dict()\n        mapped_http_port[str(self.http_waiter.http_port)] = self.get_exposed_port(  # type: ignore\n            str(self.http_waiter.http_port)\n        )\n        EndpointWaiters.wait_for_http(\n            docker_client,\n            self.get_container_id(),  # type: ignore\n            self.http_waiter,\n            mapped_http_port,  # type: ignore\n        )\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.exe_command","title":"<code>exe_command(self, command: Union[str, List[str]]) -&gt; Tuple[int, ByteString]</code>","text":"<p>Execute a command inside a container after it has started running.</p> <p>Parameters:</p>    Name Type Description Default     <code>command</code> <code>Union[str, List[str]]</code> <p>command to run in the container</p> required    <p>Exceptions:</p>    Type Description     <code>RuntimeError</code> <p>when the container object is not set</p>    <p>Returns:</p>    Type Description     <code>Tuple[int, ByteString]</code> <p>A tuple of (exit_code, output)</p>     Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def exe_command(self, command: Union[str, List[str]]) -&gt; Tuple[int, ByteString]:\n    \"\"\"Execute a command inside a container after it has started running.\n\n    Args:\n        command (Union[str, List[str]]): command to run in the container\n\n    Raises:\n        RuntimeError: when the container object is not set\n\n    Returns:\n        Tuple[int, ByteString]: A tuple of (exit_code, output)\n    \"\"\"\n    if not self.container:\n        raise RuntimeError(\"Container must already be running to exec a command\")\n    return self.container.exec_run(cmd=command)\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_host_ip","title":"<code>get_container_host_ip(self) -&gt; str</code>","text":"<p>Container Host IP address</p> <p>Returns:</p>    Type Description     <code>str</code> <p>container host IP Address</p>     Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def get_container_host_ip(self) -&gt; str:\n    \"\"\"Container Host IP address\n\n    Returns:\n        str: container host IP Address\n    \"\"\"\n    return socket.gethostbyname(socket.gethostname())\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_container_id","title":"<code>get_container_id(self) -&gt; Optional[str]</code>","text":"<p>Container id</p> <p>Returns:</p>    Type Description     <code>Optional[str]</code> <p>Container Id</p>     Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def get_container_id(self) -&gt; Optional[str]:\n    \"\"\"Container id\n\n    Returns:\n        Optional[str]: Container Id\n    \"\"\"\n    if self.container:\n        return self.container.id\n    return None\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.get_exposed_port","title":"<code>get_exposed_port(self, port: str) -&gt; Optional[str]</code>","text":"<p>Get host port bound to the container exposed port</p> <p>Parameters:</p>    Name Type Description Default     <code>port</code> <code>str</code> <p>container exposed port</p> required    <p>Returns:</p>    Type Description     <code>str</code> <p>Host port bound to the container exposed port</p>     Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def get_exposed_port(self, port: str) -&gt; Optional[str]:\n    \"\"\"Get host port bound to the container exposed port\n\n    Args:\n        port (str): container exposed port\n\n    Returns:\n        str: Host port bound to the container exposed port\n    \"\"\"\n    if not port:\n        return None\n    return self._get_mapped_container_ports([port])[port]\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.reload","title":"<code>reload(self, docker_client, container_id) -&gt; None</code>","text":"<p>Reload the attributes of a running container</p>  Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def reload(self, docker_client, container_id) -&gt; None:\n    \"\"\"Reload the attributes of a running container\"\"\"\n    if is_container_still_running(docker_client, container_id):\n        self.container.reload()\n        self.container_attr = self.container.attrs  # type: ignore\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.start","title":"<code>start(self, docker_client: DockerClient) -&gt; Container</code>","text":"<p>Start a container</p>  Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def start(self, docker_client: DockerClient) -&gt; Container:\n    \"\"\"Start a container\"\"\"\n    if not docker_client.ping():\n        raise RuntimeError(\"Docker Client not Running. Please check your docker settings and try again\")\n\n    return docker_client.containers.run(\n        image=self.image,\n        command=self.command,\n        detach=True,\n        environment=self.container_environment_variables,\n        ports=self.ports,\n        volumes=self.volumes,\n        entrypoint=self.entry_point,\n        auto_remove=True,\n        remove=True,\n        network=self.network,\n        hostname=self.host_name,\n    )  # type: ignore\n</code></pre>"},{"location":"api/#testcompose.containers.generic_container.GenericContainer.stop","title":"<code>stop(self, force = True, delete_volume = True) -&gt; None</code>","text":"<p>Stop a running container</p> <p>Parameters:</p>    Name Type Description Default     <code>force</code> <code>bool</code> <p>[description]. Defaults to True.</p> <code>True</code>   <code>delete_volume</code> <code>bool</code> <p>[description]. Defaults to True.</p> <code>True</code>     Source code in <code>testcompose/containers/generic_container.py</code> <pre><code>def stop(self, force=True, delete_volume=True) -&gt; None:\n    \"\"\"Stop a running container\n    Args:\n        force (bool, optional): [description]. Defaults to True.\n        delete_volume (bool, optional): [description]. Defaults to True.\n    \"\"\"\n    try:\n        if self.container:\n            self.container.remove(v=delete_volume, force=force)\n    except APIError as exc:\n        logger.error(exc)\n</code></pre>"},{"location":"api/#testcompose.models.container.supported_placeholders.SupportedPlaceholders","title":"<code> testcompose.models.container.supported_placeholders.SupportedPlaceholders        </code>  <code>dataclass</code>","text":"<p>SupportedPlaceholders(SELF_HOST: str = 'self', CONTAINER_HOSTNAME: str = 'container_hostname', EXTERNAL_PORT: str = 'external_port', CONTAINER_HOST_ADDRESS: str = 'container_host_address')</p>  Source code in <code>testcompose/models/container/supported_placeholders.py</code> <pre><code>@dataclass(frozen=True)\nclass SupportedPlaceholders:\n    SELF_HOST: str = 'self'\n    CONTAINER_HOSTNAME: str = 'container_hostname'\n    EXTERNAL_PORT: str = 'external_port'\n    CONTAINER_HOST_ADDRESS: str = 'container_host_address'\n</code></pre>"},{"location":"api/#testcompose.models.container.supported_placeholders.SupportedPlaceholders.CONTAINER_HOSTNAME","title":"<code>CONTAINER_HOSTNAME: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.container.supported_placeholders.SupportedPlaceholders.CONTAINER_HOST_ADDRESS","title":"<code>CONTAINER_HOST_ADDRESS: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.container.supported_placeholders.SupportedPlaceholders.EXTERNAL_PORT","title":"<code>EXTERNAL_PORT: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.container.supported_placeholders.SupportedPlaceholders.SELF_HOST","title":"<code>SELF_HOST: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv","title":"<code> testcompose.models.client.client_login.ClientFromEnv            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>class ClientFromEnv(BaseModel):\n    use_ssh_client: bool = False\n    ssl_version: Optional[int] = None\n    assert_hostname: Optional[bool] = None\n    environment: Optional[Dict[str, Any]] = None\n    version: str = \"auto\"\n    timeout: Optional[int] = DEFAULT_TIMEOUT_SECONDS\n    max_pool_size: Optional[int] = DEFAULT_MAX_POOL_SIZE\n\n    @validator('version')\n    def validate_version(cls, v):\n        return v or \"auto\"\n\n    @validator('timeout')\n    def validate_timeout(cls, v):\n        return v or DEFAULT_TIMEOUT_SECONDS\n\n    @validator('max_pool_size')\n    def validate_max_pool_size(cls, v):\n        return v or DEFAULT_MAX_POOL_SIZE\n</code></pre>"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.assert_hostname","title":"<code>assert_hostname: bool</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.environment","title":"<code>environment: Dict[str, Any]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.max_pool_size","title":"<code>max_pool_size: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.ssl_version","title":"<code>ssl_version: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.timeout","title":"<code>timeout: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.use_ssh_client","title":"<code>use_ssh_client: bool</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.version","title":"<code>version: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.validate_max_pool_size","title":"<code>validate_max_pool_size(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>@validator('max_pool_size')\ndef validate_max_pool_size(cls, v):\n    return v or DEFAULT_MAX_POOL_SIZE\n</code></pre>"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.validate_timeout","title":"<code>validate_timeout(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>@validator('timeout')\ndef validate_timeout(cls, v):\n    return v or DEFAULT_TIMEOUT_SECONDS\n</code></pre>"},{"location":"api/#testcompose.models.client.client_login.ClientFromEnv.validate_version","title":"<code>validate_version(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>@validator('version')\ndef validate_version(cls, v):\n    return v or \"auto\"\n</code></pre>"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl","title":"<code> testcompose.models.client.client_login.ClientFromUrl            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>class ClientFromUrl(BaseModel):\n    docker_host: Optional[str] = None\n    tls: Optional[bool] = None\n    user_agent: Optional[str] = None\n    credstor_env: Optional[Dict[str, Any]] = None\n    use_ssh_client: Optional[bool] = None\n    timeout: Optional[int] = DEFAULT_TIMEOUT_SECONDS\n    max_pool_size: Optional[int] = DEFAULT_MAX_POOL_SIZE\n    version: str = \"auto\"\n\n    @validator('version')\n    def validate_version(cls, v):\n        return v or \"auto\"\n\n    @validator('timeout')\n    def validate_timeout(cls, v):\n        return v or DEFAULT_TIMEOUT_SECONDS\n\n    @validator('max_pool_size')\n    def validate_max_pool_size(cls, v):\n        return v or DEFAULT_MAX_POOL_SIZE\n</code></pre>"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.credstor_env","title":"<code>credstor_env: Dict[str, Any]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.docker_host","title":"<code>docker_host: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.max_pool_size","title":"<code>max_pool_size: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.timeout","title":"<code>timeout: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.tls","title":"<code>tls: bool</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.use_ssh_client","title":"<code>use_ssh_client: bool</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.user_agent","title":"<code>user_agent: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.version","title":"<code>version: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.validate_max_pool_size","title":"<code>validate_max_pool_size(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>@validator('max_pool_size')\ndef validate_max_pool_size(cls, v):\n    return v or DEFAULT_MAX_POOL_SIZE\n</code></pre>"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.validate_timeout","title":"<code>validate_timeout(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>@validator('timeout')\ndef validate_timeout(cls, v):\n    return v or DEFAULT_TIMEOUT_SECONDS\n</code></pre>"},{"location":"api/#testcompose.models.client.client_login.ClientFromUrl.validate_version","title":"<code>validate_version(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/client/client_login.py</code> <pre><code>@validator('version')\ndef validate_version(cls, v):\n    return v or \"auto\"\n</code></pre>"},{"location":"api/#testcompose.models.client.registry_parameters.Login","title":"<code> testcompose.models.client.registry_parameters.Login            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/client/registry_parameters.py</code> <pre><code>class Login(BaseModel):\n    username: Optional[str] = None\n    password: Optional[str] = None\n    email: Optional[str] = None\n    registry: Optional[str] = None\n    reauth: Optional[bool] = False\n    dockercfg_path: Optional[str] = None\n</code></pre>"},{"location":"api/#testcompose.models.client.registry_parameters.Login.dockercfg_path","title":"<code>dockercfg_path: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.registry_parameters.Login.email","title":"<code>email: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.registry_parameters.Login.password","title":"<code>password: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.registry_parameters.Login.reauth","title":"<code>reauth: bool</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.registry_parameters.Login.registry","title":"<code>registry: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.client.registry_parameters.Login.username","title":"<code>username: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService","title":"<code> testcompose.models.bootstrap.container_service.ContainerService            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/bootstrap/container_service.py</code> <pre><code>class ContainerService(BaseModel):\n    name: str\n    image: str\n    exposed_ports: List[str]\n    command: str = ''\n    environment: Dict[str, Any] = dict()\n    depends_on: List[str] = list()\n    volumes: List[ContainerVolumeMap] = list()\n    log_wait_parameters: Optional[ContainerLogWaitParameter] = None\n    http_wait_parameters: Optional[ContainerHttpWaitParameter] = None\n    https_wait_parameters: Optional[ContainerHttpWaitParameter] = None\n    entrypoint: Optional[str] = None\n\n    @validator('name')\n    def validate_service_name(cls, v):\n        if not v:\n            raise AttributeError(\"Container Service name is required\")\n        return v\n\n    @validator('image')\n    def validate_image(cls, v):\n        if not v:\n            raise AttributeError(\"A valid image name is required\")\n        return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.command","title":"<code>command: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.depends_on","title":"<code>depends_on: List[str]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.entrypoint","title":"<code>entrypoint: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.environment","title":"<code>environment: Dict[str, Any]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.exposed_ports","title":"<code>exposed_ports: List[str]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.http_wait_parameters","title":"<code>http_wait_parameters: ContainerHttpWaitParameter</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.https_wait_parameters","title":"<code>https_wait_parameters: ContainerHttpWaitParameter</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.image","title":"<code>image: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.log_wait_parameters","title":"<code>log_wait_parameters: ContainerLogWaitParameter</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.name","title":"<code>name: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.volumes","title":"<code>volumes: List[testcompose.models.bootstrap.container_volume.ContainerVolumeMap]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.validate_image","title":"<code>validate_image(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_service.py</code> <pre><code>@validator('image')\ndef validate_image(cls, v):\n    if not v:\n        raise AttributeError(\"A valid image name is required\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerService.validate_service_name","title":"<code>validate_service_name(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_service.py</code> <pre><code>@validator('name')\ndef validate_service_name(cls, v):\n    if not v:\n        raise AttributeError(\"Container Service name is required\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerServices","title":"<code> testcompose.models.bootstrap.container_service.ContainerServices            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>ConfigServices holds Dict of Service and their names</p> <p>Parameters:</p>    Name Type Description Default     <code>services</code>  <p>Dict[name, Service]</p> required     Source code in <code>testcompose/models/bootstrap/container_service.py</code> <pre><code>class ContainerServices(BaseModel):\n    \"\"\"\n    ConfigServices holds Dict of Service and their names\n    Args:\n        services: Dict[name, Service]\n    \"\"\"\n\n    services: Dict[str, ContainerService]\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_service.ContainerServices.services","title":"<code>services: Dict[str, testcompose.models.bootstrap.container_service.ContainerService]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_service.RankedContainerServices","title":"<code> testcompose.models.bootstrap.container_service.RankedContainerServices            (BaseModel)         </code>  <code>pydantic-model</code>","text":"<p>RankedConfigServices holds a dict of services ranked in the order they are to be started.</p> <p>Parameters:</p>    Name Type Description Default     <code>ranked_services</code>  <p>Dict[rank, name]</p> required     Source code in <code>testcompose/models/bootstrap/container_service.py</code> <pre><code>class RankedContainerServices(BaseModel):\n    \"\"\"\n    RankedConfigServices holds a dict of services ranked in the order they are to\n    be started.\n    Args:\n        ranked_services: Dict[rank, name]\n    \"\"\"\n\n    ranked_services: Dict[int, str] = dict()\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_service.RankedContainerServices.ranked_services","title":"<code>ranked_services: Dict[int, str]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter","title":"<code> testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/bootstrap/container_http_wait_parameter.py</code> <pre><code>class ContainerHttpWaitParameter(BaseModel):\n    http_port: int\n    response_status_code: int = 200\n    startup_delay_time_ms: int = 20000\n    end_point: str = '/'\n    use_https: bool = False\n\n    @validator('http_port')\n    def validate_http_port(cls, v) -&gt; int:\n        if not v or not isinstance(v, int):\n            raise AttributeError(\"A valide Integer exposed Http port must be provided\")\n        return v\n\n    @validator('end_point')\n    def validate_end_point(cls, v) -&gt; str:\n        if not v or not isinstance(v, str):\n            raise AttributeError(\"A valide Http endpoint must be provided\")\n        return v\n\n    @validator('response_status_code')\n    def validate_response_status_code(cls, v) -&gt; int:\n        if not v or not isinstance(v, int):\n            raise AttributeError(\"A valide Integer Http response code must be provided\")\n        return v\n\n    @validator('startup_delay_time_ms')\n    def validate_startup_delay_time_ms(cls, v) -&gt; int:\n        if not v or not isinstance(v, int):\n            return 20000\n        return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.end_point","title":"<code>end_point: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.http_port","title":"<code>http_port: int</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.response_status_code","title":"<code>response_status_code: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.startup_delay_time_ms","title":"<code>startup_delay_time_ms: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.use_https","title":"<code>use_https: bool</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.validate_end_point","title":"<code>validate_end_point(v) -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_http_wait_parameter.py</code> <pre><code>@validator('end_point')\ndef validate_end_point(cls, v) -&gt; str:\n    if not v or not isinstance(v, str):\n        raise AttributeError(\"A valide Http endpoint must be provided\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.validate_http_port","title":"<code>validate_http_port(v) -&gt; int</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_http_wait_parameter.py</code> <pre><code>@validator('http_port')\ndef validate_http_port(cls, v) -&gt; int:\n    if not v or not isinstance(v, int):\n        raise AttributeError(\"A valide Integer exposed Http port must be provided\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.validate_response_status_code","title":"<code>validate_response_status_code(v) -&gt; int</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_http_wait_parameter.py</code> <pre><code>@validator('response_status_code')\ndef validate_response_status_code(cls, v) -&gt; int:\n    if not v or not isinstance(v, int):\n        raise AttributeError(\"A valide Integer Http response code must be provided\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_http_wait_parameter.ContainerHttpWaitParameter.validate_startup_delay_time_ms","title":"<code>validate_startup_delay_time_ms(v) -&gt; int</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_http_wait_parameter.py</code> <pre><code>@validator('startup_delay_time_ms')\ndef validate_startup_delay_time_ms(cls, v) -&gt; int:\n    if not v or not isinstance(v, int):\n        return 20000\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_log_wait_parameter.ContainerLogWaitParameter","title":"<code> testcompose.models.bootstrap.container_log_wait_parameter.ContainerLogWaitParameter            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/bootstrap/container_log_wait_parameter.py</code> <pre><code>class ContainerLogWaitParameter(BaseModel):\n    log_line_regex: str\n    wait_timeout_ms: int = 60000\n    poll_interval_ms: int = 10000\n\n    @validator('log_line_regex')\n    def validate_log_line_regex(cls, v):\n        if not v:\n            raise AttributeError(\"log_line_prefix must be set\")\n        return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_log_wait_parameter.ContainerLogWaitParameter.log_line_regex","title":"<code>log_line_regex: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_log_wait_parameter.ContainerLogWaitParameter.poll_interval_ms","title":"<code>poll_interval_ms: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_log_wait_parameter.ContainerLogWaitParameter.wait_timeout_ms","title":"<code>wait_timeout_ms: int</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_log_wait_parameter.ContainerLogWaitParameter.validate_log_line_regex","title":"<code>validate_log_line_regex(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_log_wait_parameter.py</code> <pre><code>@validator('log_line_regex')\ndef validate_log_line_regex(cls, v):\n    if not v:\n        raise AttributeError(\"log_line_prefix must be set\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_volume.VolumeSourceTypes","title":"<code> testcompose.models.bootstrap.container_volume.VolumeSourceTypes        </code>  <code>dataclass</code>","text":"<p>VolumeSourceTypes(FILESYSTEM_SOURCE: str = 'filesystem', DOCKER_VOLUME_SOURCE: str = 'dockervolume')</p>  Source code in <code>testcompose/models/bootstrap/container_volume.py</code> <pre><code>@dataclass(frozen=True)\nclass VolumeSourceTypes:\n    FILESYSTEM_SOURCE: str = \"filesystem\"\n    DOCKER_VOLUME_SOURCE: str = \"dockervolume\"\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_volume.VolumeSourceTypes.DOCKER_VOLUME_SOURCE","title":"<code>DOCKER_VOLUME_SOURCE: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_volume.VolumeSourceTypes.FILESYSTEM_SOURCE","title":"<code>FILESYSTEM_SOURCE: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap","title":"<code> testcompose.models.bootstrap.container_volume.ContainerVolumeMap            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/bootstrap/container_volume.py</code> <pre><code>class ContainerVolumeMap(BaseModel):\n    host: str\n    container: str\n    mode: str = 'ro'\n    source: str = VolumeSourceTypes.DOCKER_VOLUME_SOURCE\n\n    @validator('mode')\n    def validate_mode(cls, v) -&gt; str:\n        assert str(v).lower() in ['ro', 'rw']\n        return v\n\n    @validator('source')\n    def validate_source(cls, v):\n        assert str(v).lower() in ['filesystem', 'dockervolume']\n        return v\n\n    @validator('host')\n    def validate_host(cls, v):\n        if not v:\n            raise AttributeError(\"Volume Host option can not be empty or None\")\n        return v\n\n    @validator('container')\n    def validate_container(cls, v):\n        if not v:\n            raise AttributeError(\"Volume container option can not be empty or None\")\n        return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.container","title":"<code>container: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.host","title":"<code>host: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.mode","title":"<code>mode: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.source","title":"<code>source: str</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.validate_container","title":"<code>validate_container(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_volume.py</code> <pre><code>@validator('container')\ndef validate_container(cls, v):\n    if not v:\n        raise AttributeError(\"Volume container option can not be empty or None\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.validate_host","title":"<code>validate_host(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_volume.py</code> <pre><code>@validator('host')\ndef validate_host(cls, v):\n    if not v:\n        raise AttributeError(\"Volume Host option can not be empty or None\")\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.validate_mode","title":"<code>validate_mode(v) -&gt; str</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_volume.py</code> <pre><code>@validator('mode')\ndef validate_mode(cls, v) -&gt; str:\n    assert str(v).lower() in ['ro', 'rw']\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.bootstrap.container_volume.ContainerVolumeMap.validate_source","title":"<code>validate_source(v)</code>  <code>classmethod</code>","text":"Source code in <code>testcompose/models/bootstrap/container_volume.py</code> <pre><code>@validator('source')\ndef validate_source(cls, v):\n    assert str(v).lower() in ['filesystem', 'dockervolume']\n    return v\n</code></pre>"},{"location":"api/#testcompose.models.container.running_container_attributes.PossibleContainerStates","title":"<code> testcompose.models.container.running_container_attributes.PossibleContainerStates        </code>  <code>dataclass</code>","text":"<p>PossibleContainerStates(RUNNING: str = 'running', EXITED: str = 'exited')</p>  Source code in <code>testcompose/models/container/running_container_attributes.py</code> <pre><code>@dataclass(frozen=True)\nclass PossibleContainerStates:\n    RUNNING: str = 'running'\n    EXITED: str = 'exited'\n</code></pre>"},{"location":"api/#testcompose.models.container.running_container_attributes.PossibleContainerStates.EXITED","title":"<code>EXITED: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.PossibleContainerStates.RUNNING","title":"<code>RUNNING: str</code>  <code>dataclass-field</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState","title":"<code> testcompose.models.container.running_container_attributes.ContainerState            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/container/running_container_attributes.py</code> <pre><code>class ContainerState(BaseModel):\n    Status: str\n    Running: bool\n    Paused: bool\n    Restarting: bool\n    OOMKilled: bool\n    Dead: bool\n    Pid: int\n    ExitCode: int\n    Error: str\n    StartedAt: str\n    FinishedAt: str\n</code></pre>"},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Dead","title":"<code>Dead: bool</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Error","title":"<code>Error: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.ExitCode","title":"<code>ExitCode: int</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.FinishedAt","title":"<code>FinishedAt: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.OOMKilled","title":"<code>OOMKilled: bool</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Paused","title":"<code>Paused: bool</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Pid","title":"<code>Pid: int</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Restarting","title":"<code>Restarting: bool</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Running","title":"<code>Running: bool</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.StartedAt","title":"<code>StartedAt: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.ContainerState.Status","title":"<code>Status: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes","title":"<code> testcompose.models.container.running_container_attributes.RunningContainerAttributes            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/container/running_container_attributes.py</code> <pre><code>class RunningContainerAttributes(BaseModel):\n    Id: str\n    State: ContainerState\n    Platform: str\n    NetworkSettings: ContainerNetworkSettings\n</code></pre>"},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.Id","title":"<code>Id: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.NetworkSettings","title":"<code>NetworkSettings: ContainerNetworkSettings</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.Platform","title":"<code>Platform: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.container.running_container_attributes.RunningContainerAttributes.State","title":"<code>State: ContainerState</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.NetworkComponents","title":"<code> testcompose.models.network.network.NetworkComponents            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/network/network.py</code> <pre><code>class NetworkComponents(BaseModel):\n    Aliases: Optional[List[str]] = None\n    NetworkID: str\n    EndpointID: str\n    Gateway: str\n    IPAddress: str\n</code></pre>"},{"location":"api/#testcompose.models.network.network.NetworkComponents.Aliases","title":"<code>Aliases: List[str]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.network.network.NetworkComponents.EndpointID","title":"<code>EndpointID: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.NetworkComponents.Gateway","title":"<code>Gateway: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.NetworkComponents.IPAddress","title":"<code>IPAddress: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.NetworkComponents.NetworkID","title":"<code>NetworkID: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.ContainerMappedPorts","title":"<code> testcompose.models.network.network.ContainerMappedPorts            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/network/network.py</code> <pre><code>class ContainerMappedPorts(BaseModel):\n    HostIp: str\n    HostPort: str\n</code></pre>"},{"location":"api/#testcompose.models.network.network.ContainerMappedPorts.HostIp","title":"<code>HostIp: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.ContainerMappedPorts.HostPort","title":"<code>HostPort: str</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.ContainerNetworkSettings","title":"<code> testcompose.models.network.network.ContainerNetworkSettings            (BaseModel)         </code>  <code>pydantic-model</code>","text":"Source code in <code>testcompose/models/network/network.py</code> <pre><code>class ContainerNetworkSettings(BaseModel):\n    Ports: Dict[str, Any] = dict()\n    Networks: Dict[str, NetworkComponents]\n</code></pre>"},{"location":"api/#testcompose.models.network.network.ContainerNetworkSettings.Networks","title":"<code>Networks: Dict[str, testcompose.models.network.network.NetworkComponents]</code>  <code>pydantic-field</code> <code>required</code>","text":""},{"location":"api/#testcompose.models.network.network.ContainerNetworkSettings.Ports","title":"<code>Ports: Dict[str, Any]</code>  <code>pydantic-field</code>","text":""},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers","title":"<code> testcompose.models.network.network.DefaultNeworkDrivers        </code>  <code>dataclass</code>","text":"<p>DefaultNeworkDrivers()</p>  Source code in <code>testcompose/models/network/network.py</code> <pre><code>@dataclass(frozen=True)\nclass DefaultNeworkDrivers:\n    DEFAULT_BRIDGE_NETWORK = 'bridge'\n    DEFAULT_HOST_NETWORK = 'host'\n    DEFAULT_NULL_NETWORK = 'null'\n</code></pre>"},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers.DEFAULT_BRIDGE_NETWORK","title":"<code>DEFAULT_BRIDGE_NETWORK</code>","text":""},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers.DEFAULT_HOST_NETWORK","title":"<code>DEFAULT_HOST_NETWORK</code>","text":""},{"location":"api/#testcompose.models.network.network.DefaultNeworkDrivers.DEFAULT_NULL_NETWORK","title":"<code>DEFAULT_NULL_NETWORK</code>","text":""},{"location":"api/#testcompose.waiters.endpoint_waiters.EndpointWaiters","title":"<code> testcompose.waiters.endpoint_waiters.EndpointWaiters        </code>","text":"Source code in <code>testcompose/waiters/endpoint_waiters.py</code> <pre><code>class EndpointWaiters:\n    @staticmethod\n    def _get_container_host_ip() -&gt; str:\n        \"\"\"The host IP where the container runs\n\n        Returns:\n            str: host IP\n        \"\"\"\n        return socket.gethostbyname(socket.gethostname())\n\n    @staticmethod\n    def _check_endpoint(\n        docker_client: DockerClient,\n        container_id: str,\n        wait_parameter: ContainerHttpWaitParameter,\n        exposed_ports: Dict[str, str],\n    ) -&gt; None:\n        \"\"\"Endpoint health-check for a container. A running service\n        with an exposed endpoint is queried and the response code is\n        checked with the expected response code.\n\n        Args:\n            http_port (str): container service port\n            status_code (int, optional): Defaults to 200.\n            end_point (str, optional): Provided service endpoint. Defaults to \"/\".\n            server_startup_time (int, optional): Expected wait time for the service to start. Defaults to 20.\n\n        Returns:\n            bool: Endpoint returned expected status code\n        \"\"\"\n        response_check: bool = True\n        for _ in range(0, 3):\n            sleep(wait_parameter.startup_delay_time_ms / 1000)\n            if not is_container_still_running(docker_client, container_id):\n                response_check = False\n                break\n            try:\n                host: str = EndpointWaiters._get_container_host_ip()\n                mapped_port: str = exposed_ports[str(wait_parameter.http_port)]\n                scheme: str = \"https://\" if wait_parameter.use_https else \"http://\"\n                site_url: str = scheme + f\"{host}:{mapped_port}/{wait_parameter.end_point.lstrip('/')}\"\n                response: Response = get(url=site_url.rstrip(\"/\"))\n                if response.status_code == wait_parameter.response_status_code:\n                    break\n            except Exception as exc:\n                response_check = False\n                logger.error(\"HTTP_CHECK_ERROR: %s\", exc)\n        if not response_check:\n            raise RuntimeError(f\"Http check on port {wait_parameter.http_port} failed\")\n        return\n\n    @staticmethod\n    def wait_for_http(\n        docker_client: DockerClient,\n        container_id: str,\n        wait_parameter: ContainerHttpWaitParameter,\n        exposed_ports: Dict[str, str],\n    ) -&gt; None:\n        if wait_parameter:\n            EndpointWaiters._check_endpoint(docker_client, container_id, wait_parameter, exposed_ports)\n</code></pre>"},{"location":"api/#testcompose.waiters.endpoint_waiters.EndpointWaiters.wait_for_http","title":"<code>wait_for_http(docker_client: DockerClient, container_id: str, wait_parameter: ContainerHttpWaitParameter, exposed_ports: Dict[str, str]) -&gt; None</code>  <code>staticmethod</code>","text":"Source code in <code>testcompose/waiters/endpoint_waiters.py</code> <pre><code>@staticmethod\ndef wait_for_http(\n    docker_client: DockerClient,\n    container_id: str,\n    wait_parameter: ContainerHttpWaitParameter,\n    exposed_ports: Dict[str, str],\n) -&gt; None:\n    if wait_parameter:\n        EndpointWaiters._check_endpoint(docker_client, container_id, wait_parameter, exposed_ports)\n</code></pre>"},{"location":"api/#testcompose.waiters.log_waiters.LogWaiter","title":"<code> testcompose.waiters.log_waiters.LogWaiter        </code>","text":"Source code in <code>testcompose/waiters/log_waiters.py</code> <pre><code>class LogWaiter:\n    @staticmethod\n    def search_container_logs(\n        docker_client: DockerClient, container: Container, log_parameter: ContainerLogWaitParameter\n    ) -&gt; None:\n        \"\"\"Search for a given predicate in the container log. Useful to check if a\n        container is running and healthy\n\n        Args:\n            search_string (str): predicate to search in the log\n            timeout (float, optional): Defaults to 300.0.\n            interval (int, optional): Defaults to 1.\n\n        Raises:\n            ValueError: if a non string predicate is passed\n\n        Returns:\n            bool: True if the log contains the provided predicate\n        \"\"\"\n        if not log_parameter:\n            return\n\n        if not isinstance(log_parameter.log_line_regex, str):\n            raise ValueError\n\n        prog = re.compile(log_parameter.log_line_regex, re.MULTILINE).search\n        start: datetime = datetime.now()\n        output: Optional[Match[str]] = None\n        while (datetime.now() - start).total_seconds() &lt; (log_parameter.wait_timeout_ms / 1000):\n            if not is_container_still_running(docker_client, container.id):  # type: ignore\n                return\n            output = prog(container.logs().decode())\n            if output:\n                return\n            if (datetime.now() - start).total_seconds() &gt; (log_parameter.wait_timeout_ms / 1000):\n                raise TimeoutError(\n                    \"container %s did not emit logs satisfying predicate in %.3f seconds\"\n                    % (container.name, float(log_parameter.wait_timeout_ms or 60000))\n                )\n            sleep(log_parameter.poll_interval_ms / 1000)\n        logger.info(container.logs().decode())\n</code></pre>"},{"location":"api/#testcompose.waiters.log_waiters.LogWaiter.search_container_logs","title":"<code>search_container_logs(docker_client: DockerClient, container: Container, log_parameter: ContainerLogWaitParameter) -&gt; None</code>  <code>staticmethod</code>","text":"<p>Search for a given predicate in the container log. Useful to check if a container is running and healthy</p> <p>Parameters:</p>    Name Type Description Default     <code>search_string</code> <code>str</code> <p>predicate to search in the log</p> required   <code>timeout</code> <code>float</code> <p>Defaults to 300.0.</p> required   <code>interval</code> <code>int</code> <p>Defaults to 1.</p> required    <p>Exceptions:</p>    Type Description     <code>ValueError</code> <p>if a non string predicate is passed</p>    <p>Returns:</p>    Type Description     <code>bool</code> <p>True if the log contains the provided predicate</p>     Source code in <code>testcompose/waiters/log_waiters.py</code> <pre><code>@staticmethod\ndef search_container_logs(\n    docker_client: DockerClient, container: Container, log_parameter: ContainerLogWaitParameter\n) -&gt; None:\n    \"\"\"Search for a given predicate in the container log. Useful to check if a\n    container is running and healthy\n\n    Args:\n        search_string (str): predicate to search in the log\n        timeout (float, optional): Defaults to 300.0.\n        interval (int, optional): Defaults to 1.\n\n    Raises:\n        ValueError: if a non string predicate is passed\n\n    Returns:\n        bool: True if the log contains the provided predicate\n    \"\"\"\n    if not log_parameter:\n        return\n\n    if not isinstance(log_parameter.log_line_regex, str):\n        raise ValueError\n\n    prog = re.compile(log_parameter.log_line_regex, re.MULTILINE).search\n    start: datetime = datetime.now()\n    output: Optional[Match[str]] = None\n    while (datetime.now() - start).total_seconds() &lt; (log_parameter.wait_timeout_ms / 1000):\n        if not is_container_still_running(docker_client, container.id):  # type: ignore\n            return\n        output = prog(container.logs().decode())\n        if output:\n            return\n        if (datetime.now() - start).total_seconds() &gt; (log_parameter.wait_timeout_ms / 1000):\n            raise TimeoutError(\n                \"container %s did not emit logs satisfying predicate in %.3f seconds\"\n                % (container.name, float(log_parameter.wait_timeout_ms or 60000))\n            )\n        sleep(log_parameter.poll_interval_ms / 1000)\n    logger.info(container.logs().decode())\n</code></pre>"},{"location":"api/#testcompose.run_containers.RunContainers","title":"<code> testcompose.run_containers.RunContainers            (BaseDockerClient)         </code>","text":"Source code in <code>testcompose/run_containers.py</code> <pre><code>class RunContainers(BaseDockerClient):\n    def __init_subclass__(cls, **kwargs) -&gt; None:\n        if cls is not RunContainers:\n            raise TypeError(\"The class RunContainers can not be extended\")\n        return super().__init_subclass__()\n\n    def __init__(\n        self,\n        config_services: ContainerServices,\n        ranked_services: RankedContainerServices,\n        wait_time_between_container_start: float = 20.0,\n        registry_login_param=Login(),\n        env_param: ClientFromEnv = ClientFromEnv(),\n        url_param: ClientFromUrl = ClientFromUrl(),\n    ) -&gt; None:\n        super(RunContainers, self).__init__(client_env_param=env_param, client_url_param=url_param)\n        self._config_services: ContainerServices = config_services\n        self._ranked_config_services: RankedContainerServices = ranked_services\n        self.running_containers = RunningContainers()\n        self._wait_time_between_container_start: float = wait_time_between_container_start\n        self.registry_login(login_credentials=registry_login_param)\n\n    @property\n    def running_containers(self) -&gt; RunningContainers:\n        return self._running_containers\n\n    @running_containers.setter\n    def running_containers(self, containers: RunningContainers) -&gt; None:\n        self._running_containers: RunningContainers = containers\n\n    @property\n    def unique_container_label(self) -&gt; str:\n        return self._unique_container_label\n\n    @unique_container_label.setter\n    def unique_container_label(self, label: str) -&gt; None:\n        self._unique_container_label: str = label\n\n    def __enter__(self) -&gt; RunningContainers:\n        return self.run_containers()\n\n    def __exit__(self, exc_type, exc_value, exc_tb) -&gt; None:\n        self.stop_running_containers()\n        if exc_tb and exc_type:\n            logger.info(\"%s[%s]: %s\", exc_type, exc_value, exc_tb)\n\n    def run_containers(self) -&gt; RunningContainers:\n        self.unique_container_label = uuid4().hex\n        network_name: str = f\"{self.unique_container_label}_network\"\n        processed_containers_services: Dict[str, RunningContainer] = dict()\n\n        for rank in sorted(self._ranked_config_services.ranked_services.keys()):\n            service: ContainerService = self._config_services.services[\n                self._ranked_config_services.ranked_services[rank]\n            ]\n            self.pull_docker_image(service.image)\n            generic_container: GenericContainer = GenericContainer()\n            generic_container.container_network = ContainerNetwork(self.docker_client, network_name)\n            generic_container.with_service(\n                service,\n                processed_containers_services,\n                generic_container.container_network.name,  # type: ignore\n            )\n            try:\n                generic_container.container = generic_container.start(self.docker_client)\n                generic_container.check_container_health(self.docker_client)\n                running_container: RunningContainer = RunningContainer(\n                    service_name=service.name,\n                    config_environment_variables=generic_container.container_environment_variables,\n                    generic_container=generic_container,\n                )\n                processed_containers_services.update({service.name: running_container})\n                time.sleep(self._wait_time_between_container_start)\n            except Exception as exc:\n                logger.error(exc)\n                self.stop_running_containers(\n                    RunningContainers(running_containers=processed_containers_services)\n                )\n                raise APIError(exc)\n        logger.info(\"The following containers were started: %s\", list(processed_containers_services.keys()))\n        self.running_containers = RunningContainers(running_containers=processed_containers_services)\n        return self.running_containers\n\n    def stop_running_containers(self, running_containers: RunningContainers = RunningContainers()) -&gt; None:\n        container_network: Optional[ContainerNetwork] = None\n        try:\n            _running_containers: RunningContainers = (\n                running_containers if running_containers.running_containers else self.running_containers\n            )\n            for rank in sorted(self._ranked_config_services.ranked_services.keys(), reverse=True):\n                service_name: str = self._ranked_config_services.ranked_services[rank]\n                if _running_containers.running_containers.get(service_name):\n                    container: GenericContainer = _running_containers.running_containers[\n                        service_name\n                    ].generic_container\n                    container.stop()\n                    if not container_network:\n                        container_network = container.container_network\n                    logger.info(\n                        \"Successfully stopped container: %s(%s): %s\",\n                        service_name,\n                        str(rank),\n                        container.get_container_id(),\n                    )\n                    time.sleep(5)\n        finally:\n            if container_network:\n                container_network.remove_network()\n</code></pre>"},{"location":"api/#testcompose.run_containers.RunContainers.running_containers","title":"<code>running_containers: RunningContainers</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.run_containers.RunContainers.unique_container_label","title":"<code>unique_container_label: str</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/#testcompose.run_containers.RunContainers.run_containers","title":"<code>run_containers(self) -&gt; RunningContainers</code>","text":"Source code in <code>testcompose/run_containers.py</code> <pre><code>def run_containers(self) -&gt; RunningContainers:\n    self.unique_container_label = uuid4().hex\n    network_name: str = f\"{self.unique_container_label}_network\"\n    processed_containers_services: Dict[str, RunningContainer] = dict()\n\n    for rank in sorted(self._ranked_config_services.ranked_services.keys()):\n        service: ContainerService = self._config_services.services[\n            self._ranked_config_services.ranked_services[rank]\n        ]\n        self.pull_docker_image(service.image)\n        generic_container: GenericContainer = GenericContainer()\n        generic_container.container_network = ContainerNetwork(self.docker_client, network_name)\n        generic_container.with_service(\n            service,\n            processed_containers_services,\n            generic_container.container_network.name,  # type: ignore\n        )\n        try:\n            generic_container.container = generic_container.start(self.docker_client)\n            generic_container.check_container_health(self.docker_client)\n            running_container: RunningContainer = RunningContainer(\n                service_name=service.name,\n                config_environment_variables=generic_container.container_environment_variables,\n                generic_container=generic_container,\n            )\n            processed_containers_services.update({service.name: running_container})\n            time.sleep(self._wait_time_between_container_start)\n        except Exception as exc:\n            logger.error(exc)\n            self.stop_running_containers(\n                RunningContainers(running_containers=processed_containers_services)\n            )\n            raise APIError(exc)\n    logger.info(\"The following containers were started: %s\", list(processed_containers_services.keys()))\n    self.running_containers = RunningContainers(running_containers=processed_containers_services)\n    return self.running_containers\n</code></pre>"},{"location":"api/#testcompose.run_containers.RunContainers.stop_running_containers","title":"<code>stop_running_containers(self, running_containers: RunningContainers = RunningContainers(running_containers={})) -&gt; None</code>","text":"Source code in <code>testcompose/run_containers.py</code> <pre><code>def stop_running_containers(self, running_containers: RunningContainers = RunningContainers()) -&gt; None:\n    container_network: Optional[ContainerNetwork] = None\n    try:\n        _running_containers: RunningContainers = (\n            running_containers if running_containers.running_containers else self.running_containers\n        )\n        for rank in sorted(self._ranked_config_services.ranked_services.keys(), reverse=True):\n            service_name: str = self._ranked_config_services.ranked_services[rank]\n            if _running_containers.running_containers.get(service_name):\n                container: GenericContainer = _running_containers.running_containers[\n                    service_name\n                ].generic_container\n                container.stop()\n                if not container_network:\n                    container_network = container.container_network\n                logger.info(\n                    \"Successfully stopped container: %s(%s): %s\",\n                    service_name,\n                    str(rank),\n                    container.get_container_id(),\n                )\n                time.sleep(5)\n    finally:\n        if container_network:\n            container_network.remove_network()\n</code></pre>"},{"location":"environment_variables/","title":"Environment Variables","text":"<p>These are generally variables exposed on a running container as environment variables. The can be specified in the configuration as:</p> <pre><code>...\nenvironment:\n  SOMEKEY_1: some_value_1\n  SOMEKEY_2: some_value_2\n  SOMEKEY_3: some_value_3\n...\n</code></pre> <p>The above variables <code>SOMEKEY_1</code>, <code>SOMEKEY_2</code> and <code>SOMEKEY_3</code> will be available from within the container as environment variables. Place holder variables from another container can also be used in a container as environment variables as long as the container looking to expose such variables depends on the other contnainer. i.e</p> <pre><code>services:\n  - name: app1\n    image: \"node\"\n    auto_remove: True\n    command: \"\"\n    environment:\n      SOMEKEY_APP1_1: localhost\n      SOMEKEY_APP1_2: postgres\n      SOMEKEY_APP1_3: localtest\n    exposed_ports:\n      - 5432\n  - name: app2\n    image: \"node\"\n    command: \"\"\n    environment:\n      APP2_KEY_1: \"http://${app1.somekey_app1_1}-${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592\",\n      APP2_KEY_2: a\n    exposed_ports:\n      - 4450\n    depends_on:\n      - app1\n</code></pre> <p>The above placeholder variable <code>http://${app1.somekey_app1_1}:${app1.somekey_app1_2}/${app1.somekey_app1_3}:5592</code> of <code>app2</code> will be translated at runtime as <code>http://localhost-postgres/localtest:5592</code>. A primary requirement of this is that <code>app2</code> depends on <code>app1</code>!.</p>"},{"location":"environment_variables/#extra-environment-variables","title":"Extra Environment Variables","text":"<p>The following extra environment variables are included in all running containers regardless of whether they container environment variables of their own or not. These variables are:</p> <ul> <li><code>container_host_address</code>: This special variable exposes the hostname of the contianer host. This is mostly uuseful when an external script needs to interact with the running docker images. It is particularly useful if the host has a different hostname other than <code>localhost</code>.</li> <li><code>external_port</code>: Sometimes is is necessary to fix the host port to the running container. Even though this is greatly discouraged as it is advisable to allow <code>TestContainers</code> use random host port; some situations i.e for running Kafka docker images might require one to know the host port prior to starting the docker image. This is usually of the format <code>external_port_PORT_NUMBER</code>. As an example, assuming one would like to map the internal docker port 9092 with a random host port at container startup, one should specify this variable as <code>external_port_9092</code>.</li> </ul> <p><code>Testcompose</code> in this case assigns a random available port to be mapped with the port <code>9092</code>. - <code>container_hostname</code>: This is mainly the hostname of the docker image as seen within the created docker network. Usually, this is assigned the service name provided in the config. - <code>self</code>: This is a keyword use to mean the <code>current</code> image itself. E.g to specify the hostname of a service in its environment variable, one could write <code>http://${self.container_hostname}/ping</code> which will replace the plaeholder variable at startup.</p> <p>To use this set of variables, the <code>yaml</code> config above could be extended as shown:</p> <pre><code>services:\n  - name: app1\n    image: \"node\"\n    auto_remove: True\n    command: \"\"\n    environment:\n      SOMEKEY_APP1_1: localhost\n      SOMEKEY_APP1_2: postgres\n      SOMEKEY_APP1_3: localtest\n    exposed_ports:\n      - 5432\n  - name: app2\n    image: \"node\"\n    auto_remove: True\n    command: \"\"\n    environment:\n      APP2_KEY_1: \"http://${app1.container_hostname}/${app1.somekey_app1_3}:5592\",\n      APP2_KEY_2: a\n    exposed_ports:\n      - 4450\n    depends_on:\n      - app1\n</code></pre> <p>And this will be translated as <code>http://${app1.docker_python_internal_host}/${app1.somekey_app1_3}:5592</code> -&gt; <code>http://app1-runtimehostname/localtest:5592</code>. Where <code>app1-runtimehostname</code> is determined at runtime.</p> <p>The variable combination of with the keywords might vary depending on what usage is intended. One could use a combination of <code>self</code> with all the other specifal variables e.g <code>${self.container_hostname}</code>, <code>${self.container_host_address}</code> and so on. As well as using it in a different form with <code>self</code> replaced by the name of a reference service. E.g for the config above, one could specify <code>${app1.container_hostname}</code> which will be replaced with <code>app1</code> since the service name is always used as the container hostname.</p>"},{"location":"quickstart/","title":"QuickStart","text":"<p>Create a config object from a dict. See examples here</p> <pre><code>from testcompose.configs.service_config import Config\n\nrun_config = Config(test_services=ConfigServices(**config))\n</code></pre> <p>Or from a yaml file. Example here</p> <pre><code>import json\nfrom typing import Any, Dict\nfrom requests import Response, get\nfrom testcompose.configs.service_config import Config\nfrom testcompose.models.bootstrap.container_service import ContainerServices\nfrom testcompose.models.container.running_container import RunningContainer\nfrom testcompose.run_containers import RunContainers\n\nconfig_services: ContainerServices = TestConfigParser.parse_config(file_name='some-config.yaml')\nrunning_config: Config = Config(test_services=config_services)\n</code></pre> <p>The <code>some-config</code> file could contain something like the following:</p> <pre><code>services:\n  - name: database\n    image: \"postgres:13\"\n    command: \"\"\n    environment:\n      POSTGRES_USER: postgres\n      POSTGRES_DB: postgres\n      POSTGRES_PASSWORD: password\n    exposed_ports:\n      - 5432\n    log_wait_parameters:\n      log_line_regex: \"database system is ready to accept connections\"\n      wait_timeout_ms: 30000\n      poll_interval_ms: 2000\n  - name: application\n    image: \"python:3.9\"\n    command: \"/bin/bash -x /run_app.sh\"\n    environment:\n      DB_URL: \"${database.postgres_user}:${database.postgres_password}@${database.container_hostname}:5432/${database.postgres_db}\"\n    volumes:\n      - host: \"docker-test-files/run_app.sh\"\n        container: \"/run_app.sh\"\n        mode: \"ro\"\n        source: \"filesystem\"\n      - host: \"docker-test-files/app.py\"\n        container: \"/app.py\"\n        mode: \"ro\"\n        source: \"filesystem\"\n    exposed_ports:\n      - \"8000\"\n    log_wait_parameters:\n      log_line_regex: \".*Application startup complete.*\"\n      wait_timeout_ms: 45000\n      poll_interval_ms: 2000\n    http_wait_parameters:\n      http_port: 8000\n      response_status_code: 200\n      end_point: \"/ping\"\n      startup_delay_time_ms: 30000\n      use_https\": false\n    depends_on:\n      - database\n</code></pre> <p>Then let's run the containers and do some work</p> <pre><code>with RunContainers(\n        config_services=config_services,\n        ranked_services=running_config.ranked_config_services,\n) as runner:\n    assert runner\n    app_container_srv_name = \"application\"\n    app_service: RunningContainer = runner.running_containers[app_container_srv_name]\n    app_env_vars: Dict[str, Any] = app_service.config_environment_variables\n    mapped_port = app_service.generic_container.get_exposed_port(\"8000\")\n    print(app_env_vars)\n    app_host = app_service.generic_container.get_container_host_ip()\n    assert app_env_vars\n    assert mapped_port\n    assert app_host\n    response: Response = get(url=f\"http://{app_host}:{int(mapped_port)}/version\")\n    assert response\n    assert response.status_code == 200\n    assert response.text\n    assert isinstance(json.loads(response.text), dict)\n</code></pre> <p>and Voila !!! you are all set !</p>"}]}